{"version":3,"sources":["../../src/index.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js","../../src/Transport.js","../node_modules/@ledgerhq/errors/dist/index.js"],"names":["id","subscribers","log","type","obj","String","date","Date","i","e","console","dispatch","window","cb","_createForOfIteratorHelper","o","allowArrayLike","it","Symbol","iterator","Array","isArray","length","F","s","n","done","value","_e","f","TypeError","err","normalCompletion","didErr","step","next","_e2","a","data","Buffer","statusList","StatusCodes","cla","ins","p1","response","sw","busyPromise","Promise","r","resolveBusy","unresponsiveReached","timeout","setTimeout","res","clearTimeout","exchange","Error","setScrambleKey","close","on","this","off","emit","setDebugMode","setExchangeTimeout","setExchangeUnresponsiveTimeout","decorateAppAPIMethods","self","decorateAppAPIMethod","_appAPIlock","openTimeout","found","sub","error","reject","complete","listenTimeoutId","listenTimeout","Transport","isSupported","list","listen","open","ErrorMessage_ListenTimeout","ErrorMessage_NoDeviceFound","errorClasses","deserializers","addCustomErrorDeserializer","name","deserializer","createCustomErrorClass","C","message","fields","Object","assign","stack","prototype","deserializeError","object","msg","JSON","parse","name_1","des","constructor","warn","create","prop","hasOwnProperty","captureStackTrace","serializeError","destroyCircular","from","seen","to","push","_i","_a","keys","key","indexOf","slice","AccountNameRequiredError","AccountNotSupported","AmountRequired","BluetoothRequired","BtcUnmatchedApp","CantOpenDevice","CashAddrNotSupported","CurrencyNotSupported","DeviceAppVerifyNotSupported","DeviceGenuineSocketEarlyClose","DeviceNotGenuineError","DeviceOnDashboardExpected","DeviceOnDashboardUnexpected","DeviceInOSUExpected","DeviceHalted","DeviceNameInvalid","DeviceSocketFail","DeviceSocketNoBulkStatus","DisconnectedDevice","DisconnectedDeviceDuringOperation","EnpointConfigError","EthAppPleaseEnableContractData","FeeEstimationFailed","FirmwareNotRecognized","HardResetFail","InvalidXRPTag","InvalidAddress","InvalidAddressBecauseDestinationIsAlsoSource","LatestMCUInstalledError","UnknownMCU","LedgerAPIError","LedgerAPIErrorWithMessage","LedgerAPINotAvailable","ManagerAppAlreadyInstalledError","ManagerAppRelyOnBTCError","ManagerAppDepInstallRequired","ManagerAppDepUninstallRequired","ManagerDeviceLockedError","ManagerFirmwareNotEnoughSpaceError","ManagerNotEnoughSpaceError","ManagerUninstallBTCDep","NetworkDown","NoAddressesFound","NotEnoughBalance","NotEnoughBalanceToDelegate","NotEnoughBalanceInParentAccount","NotEnoughSpendableBalance","NotEnoughBalanceBecauseDestinationNotCreated","NoAccessToCamera","NotEnoughGas","NotSupportedLegacyAddress","GasLessThanEstimate","PasswordsDontMatchError","PasswordIncorrectError","RecommendSubAccountsToEmpty","RecommendUndelegation","TimeoutTagged","UnexpectedBootloader","MCUNotGenuineToDashboard","RecipientRequired","UnavailableTezosOriginatedAccountReceive","UnavailableTezosOriginatedAccountSend","UpdateFetchFileFail","UpdateIncorrectHash","UpdateIncorrectSig","UpdateYourApp","UserRefusedDeviceNameChange","UserRefusedAddress","UserRefusedFirmwareUpdate","UserRefusedAllowManager","UserRefusedOnDevice","TransportOpenUserCancelled","TransportInterfaceNotAvailable","TransportRaceCondition","TransportWebUSBGestureRequired","DeviceShouldStayInApp","WebsocketConnectionError","WebsocketConnectionFailed","WrongDeviceForAccount","WrongAppForCurrency","ETHAddressNonEIP","CantScanQRCode","FeeNotLoaded","FeeRequired","FeeTooHigh","SyncError","PairingFailed","GenuineCheckFailed","LedgerAPI4xx","LedgerAPI5xx","FirmwareOrAppUpdateRequired","NoDBPathGiven","DBWrongPassword","DBNotReset","TransportError","PIN_REMAINING_ATTEMPTS","INCORRECT_LENGTH","MISSING_CRITICAL_PARAMETER","COMMAND_INCOMPATIBLE_FILE_STRUCTURE","SECURITY_STATUS_NOT_SATISFIED","CONDITIONS_OF_USE_NOT_SATISFIED","INCORRECT_DATA","NOT_ENOUGH_MEMORY_SPACE","REFERENCED_DATA_NOT_FOUND","FILE_ALREADY_EXISTS","INCORRECT_P1_P2","INS_NOT_SUPPORTED","CLA_NOT_SUPPORTED","TECHNICAL_PROBLEM","OK","MEMORY_PROBLEM","NO_EF_SELECTED","INVALID_OFFSET","FILE_NOT_FOUND","INCONSISTENT_FILE","ALGORITHM_NOT_SUPPORTED","INVALID_KCV","CODE_NOT_INITIALIZED","ACCESS_CONDITION_NOT_FULFILLED","CONTRADICTION_SECRET_CODE_STATUS","CONTRADICTION_INVALIDATION","CODE_BLOCKED","MAX_VALUE_REACHED","GP_AUTH_FAILED","LICENSING","HALTED","getAltStatusMessage","code","TransportStatusError","statusCode","statusText","find","k","smsg","statusCodeStr","toString"],"mappings":"gIAEA,kCAaA,IAAIA,EAAJ,EACMC,EAAN,GAOaC,EAAM,SAACC,EAAD,KACjB,IAAMC,EAAW,CAAED,OAAMH,GAAIK,SAAZ,GAA0BC,KAAM,IAAIC,MACrD,IAAaH,aACb,IAAUA,UAqBZ,SAAkBF,GAChB,IAAK,IAAIM,EAAT,EAAgBA,EAAIP,EAApB,OAAwCO,IACtC,IACEP,QACA,MAAOQ,GACPC,kBAzBJC,KA+BF,qBAAWC,SACTA,0BAxBqBC,YAErB,OADAZ,UACO,WACL,IAAMO,EAAIP,UAAV,IACA,IAAIO,IAEFP,KAAiBA,EAAYA,SAA7BA,GACAA,a,kCC1CN,+CACe,SAASa,EAA2BC,EAAGC,GACpD,IAAIC,EAEJ,GAAsB,qBAAXC,QAAgD,MAAtBH,EAAEG,OAAOC,UAAmB,CAC/D,GAAIC,MAAMC,QAAQN,KAAOE,EAAK,YAA2BF,KAAOC,GAAkBD,GAAyB,kBAAbA,EAAEO,OAAqB,CAC/GL,IAAIF,EAAIE,GACZ,IAAIT,EAAI,EAEJe,EAAI,aAER,MAAO,CACLC,EAAGD,EACHE,EAAG,WACD,OAAIjB,GAAKO,EAAEO,OAAe,CACxBI,MAAM,GAED,CACLA,MAAM,EACNC,MAAOZ,EAAEP,OAGbC,EAAG,SAAWmB,GACZ,MAAMA,GAERC,EAAGN,GAIP,MAAM,IAAIO,UAAU,yIAGtB,IAEIC,EAFAC,GAAmB,EACnBC,GAAS,EAEb,MAAO,CACLT,EAAG,WACDP,EAAKF,EAAEG,OAAOC,aAEhBM,EAAG,WACD,IAAIS,EAAOjB,EAAGkB,OAEd,OADAH,EAAmBE,EAAKR,KACjBQ,GAETzB,EAAG,SAAW2B,GACZH,GAAS,EACTF,EAAMK,GAERP,EAAG,WACD,IACOG,GAAoC,MAAhBf,EAAW,QAAWA,EAAW,SAC1D,QACA,GAAIgB,EAAQ,MAAMF,O,+JCAX,E,WAA4B,sIAiF/B,IAjF+B,qDAwIlC,qDAAAM,EAAA,yDAKLC,EALK,+BAKUC,QALV,GAMLC,EANK,+BAMuB,CAACC,cANxB,MAQDH,UAAJ,KARK,sBASG,IAAI,EAAJ,eACJ,4CAA8CA,EAD1C,OAAN,oBATG,uBAckB,WACrBC,SAAc,CACZA,OAAY,CAACG,EAAKC,EAAKC,EADX,IAEZL,OAAY,CAACD,EAFD,SADhB,KAdK,UAcCO,EAdD,OAqBCC,EAAKD,eAAsBA,SAAjC,GACKL,QAAiBhB,YAAD,OAAOA,IAA5B,KAtBK,uBAuBG,IAAI,EAAJ,qBAAN,GAvBG,iCAyBL,GAzBK,4CAxIkC,2JAyNpB,qCAAAa,EAAA,0DACf,EAAJ,oBADmB,sBAEX,IAAI,EAAJ,uBAAN,iFAFiB,cAObU,EAAc,IAAIC,SAASC,YAC/BC,OAEF,wBACIC,GAAJ,EACMC,EAAUC,YAAW,WACzBF,KACA,yBACC,EAHH,qBAZmB,kBAiBCtB,IAjBD,cAiBXyB,EAjBW,OAkBjB,GACE,qBAnBe,kBAqBjB,GArBiB,yBAuBjBC,gBACA,GAAiBL,IACjB,2BAzBiB,2EAzNoB,4E,4CA8DzCM,SAAQ,GACN,MAAM,IAAIC,MAAV,8B,4BAQFC,SAAc,M,mBAMdC,WACE,OAAOX,QAAP,Y,gBAUFY,SAAE,KACAC,KAAA,kB,iBAMFC,SAAG,KACDD,KAAA,8B,kBAGFE,SAAI,GAA4B,6BAA5B,EAA4B,iCAA5B,EAA4B,mBAC9B,EAAAF,KAAA,uC,0BAMFG,WACEtD,+G,gCAQFuD,SAAkB,GAChBJ,KAAA,oB,4CAMFK,SAA8B,GAC5BL,KAAA,wB,mCA2HFM,SAAqB,OAInB,oBACA,GADA,IACA,2BAAgC,KAAhC,EAAgC,QAC9BC,KAAmBP,KAAKQ,qBAAqB,EAE3CD,EAFiB,KAAnBA,IAFF,iC,kCAYFC,SAAoB,SAKU,WAC5B,6BAAO,8CAAAhC,EAAA,2DACGiC,EAAR,EAAQA,aADH,yCAGItB,eACL,IAAI,EAAJ,eACE,+BAAiCsB,EADnC,IADF,qBAHG,oBAWH,gBACA,oBAZG,gEAaUzC,UAAb,GAbG,iEAeH,mBAfG,8E,qBAjGT,WAGkC,WAFhC0C,EAEgC,uDAHlC,MAGkC,uCAChC,OAAO,IAAIvB,SAAQ,cACjB,IAAIwB,GAAJ,EACMC,EAAM,SAAY,CACtBtC,KAAO1B,YACL+D,KACA,GAASC,gBACT,GAAqBlB,gBACrB,OAAU9C,EAAV,yBAEFiE,MAAQjE,YACN,GAAqB8C,gBACrBoB,MAEFC,SAAU,WACR,GAAqBrB,gBACrB,GACEoB,EACE,IAAI,EAAJ,eACE,EADF,2BADFA,qBASAE,EAAkBC,EACpBzB,YAAW,WACToB,gBACAE,EACE,IAAI,EAAJ,eACE,EADF,2BADFA,oBAH+B,GAArC,Y,KAxMeI,EAQXC,iB,EARWD,EAgBXE,U,EAhBWF,EAsCXG,Y,EAtCWH,EAkDXI,U,EAlDWJ,EAgSZK,2BAA6B,mCAhSjBL,EAiSZM,2BAA6B,2B,0DCrVtC,o6KAIA,IAAIC,EAAe,GACfC,EAAgB,GAChBC,EAA6B,SAAUC,EAAMC,GAC7CH,EAAcE,GAAQC,GAEtBC,EAAyB,SAAUF,GACnC,IAAIG,EAAI,SAAqBC,EAASC,GAClCC,OAAOC,OAAOnC,KAAMiC,GACpBjC,KAAK4B,KAAOA,EACZ5B,KAAKgC,QAAUA,GAAWJ,EAC1B5B,KAAKoC,OAAQ,IAAIxC,OAAQwC,OAI7B,OAFAL,EAAEM,UAAY,IAAIzC,MAClB6B,EAAaG,GAAQG,EACdA,GAGPO,EAAmB,SAAnBA,EAA6BC,GAC7B,GAAsB,kBAAXA,GAAuBA,EAAQ,CACtC,IAEI,IAAIC,EAAMC,KAAKC,MAAMH,EAAOP,SACxBQ,EAAIR,SAAWQ,EAAIZ,OACnBW,EAASC,GAGjB,MAAO5F,IAGP,IAAIiE,OAAQ,EACZ,GAA2B,kBAAhB0B,EAAOX,KAAmB,CACjC,IAAIe,EAASJ,EAAOX,KAChBgB,EAAMlB,EAAciB,GACxB,GAAIC,EACA/B,EAAQ+B,EAAIL,OAEX,CACD,IAAIM,EAAyB,UAAXF,EAAqB/C,MAAQ6B,EAAakB,GACvDE,IACDhG,QAAQiG,KAAK,mCAAqCH,EAAS,KAC3DE,EAAcf,EAAuBa,IAEzC9B,EAAQqB,OAAOa,OAAOF,EAAYR,WAClC,IACI,IAAK,IAAIW,KAAQT,EACTA,EAAOU,eAAeD,KACtBnC,EAAMmC,GAAQT,EAAOS,IAIjC,MAAOpG,WAMXiE,EAAQ,IAAIjB,MAAM2C,EAAOP,SAK7B,OAHKnB,EAAMuB,OAASxC,MAAMsD,mBACtBtD,MAAMsD,kBAAkBrC,EAAOyB,GAE5BzB,EAEX,OAAO,IAAIjB,MAAMpD,OAAO+F,KAGxBY,EAAiB,SAAUrF,GAC3B,OAAKA,EAEgB,kBAAVA,EACAsF,EAAgBtF,EAAO,IAEb,oBAAVA,EACA,eAAiBA,EAAM8D,MAAQ,aAAe,IAElD9D,EAPIA,GAUf,SAASsF,EAAgBC,EAAMC,GAC3B,IAAIC,EAAK,GACTD,EAAKE,KAAKH,GACV,IAAK,IAAII,EAAK,EAAGC,EAAKxB,OAAOyB,KAAKN,GAAOI,EAAKC,EAAGjG,OAAQgG,IAAM,CAC3D,IAAIG,EAAMF,EAAGD,GACT3F,EAAQuF,EAAKO,GACI,oBAAV9F,IAGNA,GAA0B,kBAAVA,GAIY,IAA7BwF,EAAKO,QAAQR,EAAKO,IAItBL,EAAGK,GAAO,aAHNL,EAAGK,GAAOR,EAAgBC,EAAKO,GAAMN,EAAKQ,MAAM,IAJhDP,EAAGK,GAAO9F,GAkBlB,MATyB,kBAAduF,EAAKzB,OACZ2B,EAAG3B,KAAOyB,EAAKzB,MAES,kBAAjByB,EAAKrB,UACZuB,EAAGvB,QAAUqB,EAAKrB,SAEI,kBAAfqB,EAAKjB,QACZmB,EAAGnB,MAAQiB,EAAKjB,OAEbmB,EAGX,IAAIQ,EAA2BjC,EAAuB,uBAClDkC,EAAsBlC,EAAuB,uBAC7CmC,EAAiBnC,EAAuB,kBACxCoC,EAAoBpC,EAAuB,qBAC3CqC,EAAkBrC,EAAuB,mBACzCsC,EAAiBtC,EAAuB,kBACxCuC,EAAuBvC,EAAuB,wBAC9CwC,EAAuBxC,EAAuB,wBAC9CyC,EAA8BzC,EAAuB,+BACrD0C,EAAgC1C,EAAuB,iCACvD2C,EAAwB3C,EAAuB,oBAC/C4C,EAA4B5C,EAAuB,6BACnD6C,EAA8B7C,EAAuB,+BACrD8C,EAAsB9C,EAAuB,uBAC7C+C,EAAe/C,EAAuB,gBACtCgD,EAAoBhD,EAAuB,qBAC3CiD,EAAmBjD,EAAuB,oBAC1CkD,EAA2BlD,EAAuB,4BAClDmD,EAAqBnD,EAAuB,sBAC5CoD,EAAoCpD,EAAuB,qCAC3DqD,EAAqBrD,EAAuB,iBAC5CsD,EAAiCtD,EAAuB,kCACxDuD,EAAsBvD,EAAuB,uBAC7CwD,EAAwBxD,EAAuB,yBAC/CyD,EAAgBzD,EAAuB,iBACvC0D,EAAgB1D,EAAuB,iBACvC2D,EAAiB3D,EAAuB,kBACxC4D,EAA+C5D,EAAuB,gDACtE6D,EAA0B7D,EAAuB,2BACjD8D,EAAa9D,EAAuB,cACpC+D,EAAiB/D,EAAuB,kBACxCgE,EAA4BhE,EAAuB,6BACnDiE,EAAwBjE,EAAuB,yBAC/CkE,EAAkClE,EAAuB,8BACzDmE,EAA2BnE,EAAuB,uBAClDoE,EAA+BpE,EAAuB,gCACtDqE,EAAiCrE,EAAuB,kCACxDsE,EAA2BtE,EAAuB,uBAClDuE,EAAqCvE,EAAuB,iCAC5DwE,EAA6BxE,EAAuB,yBACpDyE,EAAyBzE,EAAuB,0BAChD0E,EAAc1E,EAAuB,eACrC2E,EAAmB3E,EAAuB,oBAC1C4E,EAAmB5E,EAAuB,oBAC1C6E,GAA6B7E,EAAuB,8BACpD8E,GAAkC9E,EAAuB,mCACzD+E,GAA4B/E,EAAuB,6BACnDgF,GAA+ChF,EAAuB,gDACtEiF,GAAmBjF,EAAuB,oBAC1CkF,GAAelF,EAAuB,gBACtCmF,GAA4BnF,EAAuB,6BACnDoF,GAAsBpF,EAAuB,uBAC7CqF,GAA0BrF,EAAuB,sBACjDsF,GAAyBtF,EAAuB,qBAChDuF,GAA8BvF,EAAuB,+BACrDwF,GAAwBxF,EAAuB,yBAC/CyF,GAAgBzF,EAAuB,iBACvC0F,GAAuB1F,EAAuB,wBAC9C2F,GAA2B3F,EAAuB,4BAClD4F,GAAoB5F,EAAuB,qBAC3C6F,GAA2C7F,EAAuB,4CAClE8F,GAAwC9F,EAAuB,yCAC/D+F,GAAsB/F,EAAuB,uBAC7CgG,GAAsBhG,EAAuB,uBAC7CiG,GAAqBjG,EAAuB,sBAC5CkG,GAAgBlG,EAAuB,iBACvCmG,GAA8BnG,EAAuB,+BACrDoG,GAAqBpG,EAAuB,sBAC5CqG,GAA4BrG,EAAuB,6BACnDsG,GAA0BtG,EAAuB,2BACjDuG,GAAsBvG,EAAuB,uBAC7CwG,GAA6BxG,EAAuB,8BACpDyG,GAAiCzG,EAAuB,kCACxD0G,GAAyB1G,EAAuB,0BAChD2G,GAAiC3G,EAAuB,kCACxD4G,GAAwB5G,EAAuB,yBAC/C6G,GAA2B7G,EAAuB,4BAClD8G,GAA4B9G,EAAuB,6BACnD+G,GAAwB/G,EAAuB,yBAC/CgH,GAAsBhH,EAAuB,uBAC7CiH,GAAmBjH,EAAuB,oBAC1CkH,GAAiBlH,EAAuB,kBACxCmH,GAAenH,EAAuB,gBACtCoH,GAAcpH,EAAuB,eACrCqH,GAAarH,EAAuB,cACpCsH,GAAYtH,EAAuB,aACnCuH,GAAgBvH,EAAuB,iBACvCwH,GAAqBxH,EAAuB,sBAC5CyH,GAAezH,EAAuB,gBACtC0H,GAAe1H,EAAuB,gBACtC2H,GAA8B3H,EAAuB,+BAErD4H,GAAgB5H,EAAuB,iBACvC6H,GAAkB7H,EAAuB,mBACzC8H,GAAa9H,EAAuB,cAKxC,SAAS+H,GAAe7H,EAAS7F,GAC7B6D,KAAK4B,KAAO,iBACZ5B,KAAKgC,QAAUA,EACfhC,KAAKoC,OAAQ,IAAIxC,OAAQwC,MACzBpC,KAAK7D,GAAKA,EAEd0N,GAAexH,UAAY,IAAIzC,MAC/B+B,EAA2B,kBAAkB,SAAU/E,GAAK,OAAO,IAAIiN,GAAejN,EAAEoF,QAASpF,EAAET,OACnG,IAAIyC,GAAc,CACdkL,uBAAwB,MACxBC,iBAAkB,MAClBC,2BAA4B,MAC5BC,oCAAqC,MACrCC,8BAA+B,MAC/BC,gCAAiC,MACjCC,eAAgB,MAChBC,wBAAyB,MACzBC,0BAA2B,MAC3BC,oBAAqB,MACrBC,gBAAiB,MACjBC,kBAAmB,MACnBC,kBAAmB,MACnBC,kBAAmB,MACnBC,GAAI,MACJC,eAAgB,MAChBC,eAAgB,MAChBC,eAAgB,MAChBC,eAAgB,MAChBC,kBAAmB,MACnBC,wBAAyB,MACzBC,YAAa,MACbC,qBAAsB,MACtBC,+BAAgC,MAChCC,iCAAkC,MAClCC,2BAA4B,MAC5BC,aAAc,MACdC,kBAAmB,MACnBC,eAAgB,MAChBC,UAAW,MACXC,OAAQ,OAEZ,SAASC,GAAoBC,GACzB,OAAQA,GAEJ,KAAK,MACD,MAAO,mBACX,KAAK,MACD,MAAO,6BACX,KAAK,MACD,MAAO,uEACX,KAAK,MACD,MAAO,uDACX,KAAK,MACD,MAAO,wBACX,KAAK,MACD,MAAO,6BAEf,GAAI,OAAUA,GAAQA,GAAQ,MAC1B,MAAO,gCAOf,SAASC,GAAqBC,GAC1BhM,KAAK4B,KAAO,uBACZ,IAAIqK,EAAa/J,OAAOyB,KAAK/E,IAAasN,MAAK,SAAUC,GAAK,OAAOvN,GAAYuN,KAAOH,MACpF,gBACAI,EAAOP,GAAoBG,IAAeC,EAC1CI,EAAgBL,EAAWM,SAAS,IACxCtM,KAAKgC,QAAU,kBAAoBoK,EAAO,OAASC,EAAgB,IACnErM,KAAKoC,OAAQ,IAAIxC,OAAQwC,MACzBpC,KAAKgM,WAAaA,EAClBhM,KAAKiM,WAAaA,EAEtBF,GAAqB1J,UAAY,IAAIzC,MACrC+B,EAA2B,wBAAwB,SAAU/E,GAAK,OAAO,IAAImP,GAAqBnP,EAAEoP","file":"static/js/17.9f53b8e7.chunk.js","sourcesContent":["// @flow\n\n/**\n * A Log object\n */\nexport type Log = {\n  type: string,\n  message?: string,\n  data?: any,\n  id: string, // unique amount all logs\n  date: Date, // date of the log\n};\n\nexport type Unsubscribe = () => void;\n\nlet id = 0;\nconst subscribers = [];\n\n/**\n * log something\n * @param type a namespaced identifier of the log (it is not a level like \"debug\", \"error\" but more like \"apdu-in\", \"apdu-out\", etc...)\n * @param message a clear message of the log associated to the type\n */\nexport const log = (type: string, message?: string, data?: any) => {\n  const obj: Log = { type, id: String(++id), date: new Date() };\n  if (message) obj.message = message;\n  if (data) obj.data = data;\n  dispatch(obj);\n};\n\n/**\n * listen to logs.\n * @param cb that is called for each future log() with the Log object\n * @return a function that can be called to unsubscribe the listener\n */\nexport const listen = (cb: (Log) => void): Unsubscribe => {\n  subscribers.push(cb);\n  return () => {\n    const i = subscribers.indexOf(cb);\n    if (i !== -1) {\n      // equivalent of subscribers.splice(i, 1) // https://twitter.com/Rich_Harris/status/1125850391155965952\n      subscribers[i] = subscribers[subscribers.length - 1];\n      subscribers.pop();\n    }\n  };\n};\n\nfunction dispatch(log: Log) {\n  for (let i = 0; i < subscribers.length; i++) {\n    try {\n      subscribers[i](log);\n    } catch (e) {\n      console.error(e);\n    }\n  }\n}\n\n// for debug purpose\nif (typeof window !== \"undefined\") {\n  window.__ledgerLogsListen = listen;\n}\n","import unsupportedIterableToArray from \"@babel/runtime/helpers/esm/unsupportedIterableToArray\";\nexport default function _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}","//@flow\n\nimport EventEmitter from \"events\";\nimport type { DeviceModel } from \"@ledgerhq/devices\";\nimport {\n  TransportRaceCondition,\n  TransportError,\n  StatusCodes,\n  getAltStatusMessage,\n  TransportStatusError,\n} from \"@ledgerhq/errors\";\n\nexport {\n  TransportError,\n  TransportStatusError,\n  StatusCodes,\n  getAltStatusMessage,\n};\n\n/**\n */\nexport type Subscription = { unsubscribe: () => void };\n\n/**\n */\nexport type Device = Object;\n\n/**\n * type: add or remove event\n * descriptor: a parameter that can be passed to open(descriptor)\n * deviceModel: device info on the model (is it a nano s, nano x, ...)\n * device: transport specific device info\n */\nexport type DescriptorEvent<Descriptor> = {\n  type: \"add\" | \"remove\",\n  descriptor: Descriptor,\n  deviceModel?: ?DeviceModel,\n  device?: Device,\n};\n/**\n */\nexport type Observer<Ev> = $ReadOnly<{\n  next: (event: Ev) => mixed,\n  error: (e: any) => mixed,\n  complete: () => mixed,\n}>;\n\n/**\n * Transport defines the generic interface to share between node/u2f impl\n * A **Descriptor** is a parametric type that is up to be determined for the implementation.\n * it can be for instance an ID, an file path, a URL,...\n */\nexport default class Transport<Descriptor> {\n  exchangeTimeout: number = 30000;\n  unresponsiveTimeout: number = 15000;\n  deviceModel: ?DeviceModel = null;\n\n  /**\n   * Statically check if a transport is supported on the user's platform/browser.\n   */\n  static +isSupported: () => Promise<boolean>;\n\n  /**\n   * List once all available descriptors. For a better granularity, checkout `listen()`.\n   * @return a promise of descriptors\n   * @example\n   * TransportFoo.list().then(descriptors => ...)\n   */\n  static +list: () => Promise<Array<Descriptor>>;\n\n  /**\n   * Listen all device events for a given Transport. The method takes an Obverver of DescriptorEvent and returns a Subscription (according to Observable paradigm https://github.com/tc39/proposal-observable )\n   * a DescriptorEvent is a `{ descriptor, type }` object. type can be `\"add\"` or `\"remove\"` and descriptor is a value you can pass to `open(descriptor)`.\n   * each listen() call will first emit all potential device already connected and then will emit events can come over times,\n   * for instance if you plug a USB device after listen() or a bluetooth device become discoverable.\n   * @param observer is an object with a next, error and complete function (compatible with observer pattern)\n   * @return a Subscription object on which you can `.unsubscribe()` to stop listening descriptors.\n   * @example\nconst sub = TransportFoo.listen({\n  next: e => {\n    if (e.type===\"add\") {\n      sub.unsubscribe();\n      const transport = await TransportFoo.open(e.descriptor);\n      ...\n    }\n  },\n  error: error => {},\n  complete: () => {}\n})\n   */\n  static +listen: (\n    observer: Observer<DescriptorEvent<Descriptor>>\n  ) => Subscription;\n\n  /**\n   * attempt to create a Transport instance with potentially a descriptor.\n   * @param descriptor: the descriptor to open the transport with.\n   * @param timeout: an optional timeout\n   * @return a Promise of Transport instance\n   * @example\nTransportFoo.open(descriptor).then(transport => ...)\n   */\n  static +open: (\n    descriptor: Descriptor,\n    timeout?: number\n  ) => Promise<Transport<Descriptor>>;\n\n  /**\n   * low level api to communicate with the device\n   * This method is for implementations to implement but should not be directly called.\n   * Instead, the recommanded way is to use send() method\n   * @param apdu the data to send\n   * @return a Promise of response data\n   */\n  exchange(_apdu: Buffer): Promise<Buffer> {\n    throw new Error(\"exchange not implemented\");\n  }\n\n  /**\n   * set the \"scramble key\" for the next exchanges with the device.\n   * Each App can have a different scramble key and they internally will set it at instanciation.\n   * @param key the scramble key\n   */\n  setScrambleKey(_key: string) {}\n\n  /**\n   * close the exchange with the device.\n   * @return a Promise that ends when the transport is closed.\n   */\n  close(): Promise<void> {\n    return Promise.resolve();\n  }\n\n  _events = new EventEmitter();\n\n  /**\n   * Listen to an event on an instance of transport.\n   * Transport implementation can have specific events. Here is the common events:\n   * * `\"disconnect\"` : triggered if Transport is disconnected\n   */\n  on(eventName: string, cb: Function) {\n    this._events.on(eventName, cb);\n  }\n\n  /**\n   * Stop listening to an event on an instance of transport.\n   */\n  off(eventName: string, cb: Function) {\n    this._events.removeListener(eventName, cb);\n  }\n\n  emit(event: string, ...args: *) {\n    this._events.emit(event, ...args);\n  }\n\n  /**\n   * Enable or not logs of the binary exchange\n   */\n  setDebugMode() {\n    console.warn(\n      \"setDebugMode is deprecated. use @ledgerhq/logs instead. No logs are emitted in this anymore.\"\n    );\n  }\n\n  /**\n   * Set a timeout (in milliseconds) for the exchange call. Only some transport might implement it. (e.g. U2F)\n   */\n  setExchangeTimeout(exchangeTimeout: number) {\n    this.exchangeTimeout = exchangeTimeout;\n  }\n\n  /**\n   * Define the delay before emitting \"unresponsive\" on an exchange that does not respond\n   */\n  setExchangeUnresponsiveTimeout(unresponsiveTimeout: number) {\n    this.unresponsiveTimeout = unresponsiveTimeout;\n  }\n\n  /**\n   * wrapper on top of exchange to simplify work of the implementation.\n   * @param cla\n   * @param ins\n   * @param p1\n   * @param p2\n   * @param data\n   * @param statusList is a list of accepted status code (shorts). [0x9000] by default\n   * @return a Promise of response buffer\n   */\n  send = async (\n    cla: number,\n    ins: number,\n    p1: number,\n    p2: number,\n    data: Buffer = Buffer.alloc(0),\n    statusList: Array<number> = [StatusCodes.OK]\n  ): Promise<Buffer> => {\n    if (data.length >= 256) {\n      throw new TransportError(\n        \"data.length exceed 256 bytes limit. Got: \" + data.length,\n        \"DataLengthTooBig\"\n      );\n    }\n    const response = await this.exchange(\n      Buffer.concat([\n        Buffer.from([cla, ins, p1, p2]),\n        Buffer.from([data.length]),\n        data,\n      ])\n    );\n    const sw = response.readUInt16BE(response.length - 2);\n    if (!statusList.some((s) => s === sw)) {\n      throw new TransportStatusError(sw);\n    }\n    return response;\n  };\n\n  /**\n   * create() allows to open the first descriptor available or\n   * throw if there is none or if timeout is reached.\n   * This is a light helper, alternative to using listen() and open() (that you may need for any more advanced usecase)\n   * @example\nTransportFoo.create().then(transport => ...)\n   */\n  static create(\n    openTimeout?: number = 3000,\n    listenTimeout?: number\n  ): Promise<Transport<Descriptor>> {\n    return new Promise((resolve, reject) => {\n      let found = false;\n      const sub = this.listen({\n        next: (e) => {\n          found = true;\n          if (sub) sub.unsubscribe();\n          if (listenTimeoutId) clearTimeout(listenTimeoutId);\n          this.open(e.descriptor, openTimeout).then(resolve, reject);\n        },\n        error: (e) => {\n          if (listenTimeoutId) clearTimeout(listenTimeoutId);\n          reject(e);\n        },\n        complete: () => {\n          if (listenTimeoutId) clearTimeout(listenTimeoutId);\n          if (!found) {\n            reject(\n              new TransportError(\n                this.ErrorMessage_NoDeviceFound,\n                \"NoDeviceFound\"\n              )\n            );\n          }\n        },\n      });\n      const listenTimeoutId = listenTimeout\n        ? setTimeout(() => {\n            sub.unsubscribe();\n            reject(\n              new TransportError(\n                this.ErrorMessage_ListenTimeout,\n                \"ListenTimeout\"\n              )\n            );\n          }, listenTimeout)\n        : null;\n    });\n  }\n\n  exchangeBusyPromise: ?Promise<void>;\n\n  // $FlowFixMe\n  exchangeAtomicImpl = async (f) => {\n    if (this.exchangeBusyPromise) {\n      throw new TransportRaceCondition(\n        \"An action was already pending on the Ledger device. Please deny or reconnect.\"\n      );\n    }\n    let resolveBusy;\n    const busyPromise = new Promise((r) => {\n      resolveBusy = r;\n    });\n    this.exchangeBusyPromise = busyPromise;\n    let unresponsiveReached = false;\n    const timeout = setTimeout(() => {\n      unresponsiveReached = true;\n      this.emit(\"unresponsive\");\n    }, this.unresponsiveTimeout);\n    try {\n      const res = await f();\n      if (unresponsiveReached) {\n        this.emit(\"responsive\");\n      }\n      return res;\n    } finally {\n      clearTimeout(timeout);\n      if (resolveBusy) resolveBusy();\n      this.exchangeBusyPromise = null;\n    }\n  };\n\n  decorateAppAPIMethods(\n    self: Object,\n    methods: Array<string>,\n    scrambleKey: string\n  ) {\n    for (let methodName of methods) {\n      self[methodName] = this.decorateAppAPIMethod(\n        methodName,\n        self[methodName],\n        self,\n        scrambleKey\n      );\n    }\n  }\n\n  _appAPIlock = null;\n  decorateAppAPIMethod<R, A: any[]>(\n    methodName: string,\n    f: (...args: A) => Promise<R>,\n    ctx: *,\n    scrambleKey: string\n  ): (...args: A) => Promise<R> {\n    return async (...args) => {\n      const { _appAPIlock } = this;\n      if (_appAPIlock) {\n        return Promise.reject(\n          new TransportError(\n            \"Ledger Device is busy (lock \" + _appAPIlock + \")\",\n            \"TransportLocked\"\n          )\n        );\n      }\n      try {\n        this._appAPIlock = methodName;\n        this.setScrambleKey(scrambleKey);\n        return await f.apply(ctx, args);\n      } finally {\n        this._appAPIlock = null;\n      }\n    };\n  }\n\n  static ErrorMessage_ListenTimeout = \"No Ledger device found (timeout)\";\n  static ErrorMessage_NoDeviceFound = \"No Ledger device found\";\n}\n","/* eslint-disable no-continue */\r\n/* eslint-disable no-unused-vars */\r\n/* eslint-disable no-param-reassign */\r\n/* eslint-disable no-prototype-builtins */\r\nvar errorClasses = {};\r\nvar deserializers = {};\r\nvar addCustomErrorDeserializer = function (name, deserializer) {\r\n    deserializers[name] = deserializer;\r\n};\r\nvar createCustomErrorClass = function (name) {\r\n    var C = function CustomError(message, fields) {\r\n        Object.assign(this, fields);\r\n        this.name = name;\r\n        this.message = message || name;\r\n        this.stack = new Error().stack;\r\n    };\r\n    C.prototype = new Error();\r\n    errorClasses[name] = C;\r\n    return C;\r\n};\r\n// inspired from https://github.com/programble/errio/blob/master/index.js\r\nvar deserializeError = function (object) {\r\n    if (typeof object === \"object\" && object) {\r\n        try {\r\n            // $FlowFixMe FIXME HACK\r\n            var msg = JSON.parse(object.message);\r\n            if (msg.message && msg.name) {\r\n                object = msg;\r\n            }\r\n        }\r\n        catch (e) {\r\n            // nothing\r\n        }\r\n        var error = void 0;\r\n        if (typeof object.name === \"string\") {\r\n            var name_1 = object.name;\r\n            var des = deserializers[name_1];\r\n            if (des) {\r\n                error = des(object);\r\n            }\r\n            else {\r\n                var constructor = name_1 === \"Error\" ? Error : errorClasses[name_1];\r\n                if (!constructor) {\r\n                    console.warn(\"deserializing an unknown class '\" + name_1 + \"'\");\r\n                    constructor = createCustomErrorClass(name_1);\r\n                }\r\n                error = Object.create(constructor.prototype);\r\n                try {\r\n                    for (var prop in object) {\r\n                        if (object.hasOwnProperty(prop)) {\r\n                            error[prop] = object[prop];\r\n                        }\r\n                    }\r\n                }\r\n                catch (e) {\r\n                    // sometimes setting a property can fail (e.g. .name)\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            error = new Error(object.message);\r\n        }\r\n        if (!error.stack && Error.captureStackTrace) {\r\n            Error.captureStackTrace(error, deserializeError);\r\n        }\r\n        return error;\r\n    }\r\n    return new Error(String(object));\r\n};\r\n// inspired from https://github.com/sindresorhus/serialize-error/blob/master/index.js\r\nvar serializeError = function (value) {\r\n    if (!value)\r\n        return value;\r\n    if (typeof value === \"object\") {\r\n        return destroyCircular(value, []);\r\n    }\r\n    if (typeof value === \"function\") {\r\n        return \"[Function: \" + (value.name || \"anonymous\") + \"]\";\r\n    }\r\n    return value;\r\n};\r\n// https://www.npmjs.com/package/destroy-circular\r\nfunction destroyCircular(from, seen) {\r\n    var to = {};\r\n    seen.push(from);\r\n    for (var _i = 0, _a = Object.keys(from); _i < _a.length; _i++) {\r\n        var key = _a[_i];\r\n        var value = from[key];\r\n        if (typeof value === \"function\") {\r\n            continue;\r\n        }\r\n        if (!value || typeof value !== \"object\") {\r\n            to[key] = value;\r\n            continue;\r\n        }\r\n        if (seen.indexOf(from[key]) === -1) {\r\n            to[key] = destroyCircular(from[key], seen.slice(0));\r\n            continue;\r\n        }\r\n        to[key] = \"[Circular]\";\r\n    }\r\n    if (typeof from.name === \"string\") {\r\n        to.name = from.name;\r\n    }\r\n    if (typeof from.message === \"string\") {\r\n        to.message = from.message;\r\n    }\r\n    if (typeof from.stack === \"string\") {\r\n        to.stack = from.stack;\r\n    }\r\n    return to;\r\n}\n\nvar AccountNameRequiredError = createCustomErrorClass(\"AccountNameRequired\");\r\nvar AccountNotSupported = createCustomErrorClass(\"AccountNotSupported\");\r\nvar AmountRequired = createCustomErrorClass(\"AmountRequired\");\r\nvar BluetoothRequired = createCustomErrorClass(\"BluetoothRequired\");\r\nvar BtcUnmatchedApp = createCustomErrorClass(\"BtcUnmatchedApp\");\r\nvar CantOpenDevice = createCustomErrorClass(\"CantOpenDevice\");\r\nvar CashAddrNotSupported = createCustomErrorClass(\"CashAddrNotSupported\");\r\nvar CurrencyNotSupported = createCustomErrorClass(\"CurrencyNotSupported\");\r\nvar DeviceAppVerifyNotSupported = createCustomErrorClass(\"DeviceAppVerifyNotSupported\");\r\nvar DeviceGenuineSocketEarlyClose = createCustomErrorClass(\"DeviceGenuineSocketEarlyClose\");\r\nvar DeviceNotGenuineError = createCustomErrorClass(\"DeviceNotGenuine\");\r\nvar DeviceOnDashboardExpected = createCustomErrorClass(\"DeviceOnDashboardExpected\");\r\nvar DeviceOnDashboardUnexpected = createCustomErrorClass(\"DeviceOnDashboardUnexpected\");\r\nvar DeviceInOSUExpected = createCustomErrorClass(\"DeviceInOSUExpected\");\r\nvar DeviceHalted = createCustomErrorClass(\"DeviceHalted\");\r\nvar DeviceNameInvalid = createCustomErrorClass(\"DeviceNameInvalid\");\r\nvar DeviceSocketFail = createCustomErrorClass(\"DeviceSocketFail\");\r\nvar DeviceSocketNoBulkStatus = createCustomErrorClass(\"DeviceSocketNoBulkStatus\");\r\nvar DisconnectedDevice = createCustomErrorClass(\"DisconnectedDevice\");\r\nvar DisconnectedDeviceDuringOperation = createCustomErrorClass(\"DisconnectedDeviceDuringOperation\");\r\nvar EnpointConfigError = createCustomErrorClass(\"EnpointConfig\");\r\nvar EthAppPleaseEnableContractData = createCustomErrorClass(\"EthAppPleaseEnableContractData\");\r\nvar FeeEstimationFailed = createCustomErrorClass(\"FeeEstimationFailed\");\r\nvar FirmwareNotRecognized = createCustomErrorClass(\"FirmwareNotRecognized\");\r\nvar HardResetFail = createCustomErrorClass(\"HardResetFail\");\r\nvar InvalidXRPTag = createCustomErrorClass(\"InvalidXRPTag\");\r\nvar InvalidAddress = createCustomErrorClass(\"InvalidAddress\");\r\nvar InvalidAddressBecauseDestinationIsAlsoSource = createCustomErrorClass(\"InvalidAddressBecauseDestinationIsAlsoSource\");\r\nvar LatestMCUInstalledError = createCustomErrorClass(\"LatestMCUInstalledError\");\r\nvar UnknownMCU = createCustomErrorClass(\"UnknownMCU\");\r\nvar LedgerAPIError = createCustomErrorClass(\"LedgerAPIError\");\r\nvar LedgerAPIErrorWithMessage = createCustomErrorClass(\"LedgerAPIErrorWithMessage\");\r\nvar LedgerAPINotAvailable = createCustomErrorClass(\"LedgerAPINotAvailable\");\r\nvar ManagerAppAlreadyInstalledError = createCustomErrorClass(\"ManagerAppAlreadyInstalled\");\r\nvar ManagerAppRelyOnBTCError = createCustomErrorClass(\"ManagerAppRelyOnBTC\");\r\nvar ManagerAppDepInstallRequired = createCustomErrorClass(\"ManagerAppDepInstallRequired\");\r\nvar ManagerAppDepUninstallRequired = createCustomErrorClass(\"ManagerAppDepUninstallRequired\");\r\nvar ManagerDeviceLockedError = createCustomErrorClass(\"ManagerDeviceLocked\");\r\nvar ManagerFirmwareNotEnoughSpaceError = createCustomErrorClass(\"ManagerFirmwareNotEnoughSpace\");\r\nvar ManagerNotEnoughSpaceError = createCustomErrorClass(\"ManagerNotEnoughSpace\");\r\nvar ManagerUninstallBTCDep = createCustomErrorClass(\"ManagerUninstallBTCDep\");\r\nvar NetworkDown = createCustomErrorClass(\"NetworkDown\");\r\nvar NoAddressesFound = createCustomErrorClass(\"NoAddressesFound\");\r\nvar NotEnoughBalance = createCustomErrorClass(\"NotEnoughBalance\");\r\nvar NotEnoughBalanceToDelegate = createCustomErrorClass(\"NotEnoughBalanceToDelegate\");\r\nvar NotEnoughBalanceInParentAccount = createCustomErrorClass(\"NotEnoughBalanceInParentAccount\");\r\nvar NotEnoughSpendableBalance = createCustomErrorClass(\"NotEnoughSpendableBalance\");\r\nvar NotEnoughBalanceBecauseDestinationNotCreated = createCustomErrorClass(\"NotEnoughBalanceBecauseDestinationNotCreated\");\r\nvar NoAccessToCamera = createCustomErrorClass(\"NoAccessToCamera\");\r\nvar NotEnoughGas = createCustomErrorClass(\"NotEnoughGas\");\r\nvar NotSupportedLegacyAddress = createCustomErrorClass(\"NotSupportedLegacyAddress\");\r\nvar GasLessThanEstimate = createCustomErrorClass(\"GasLessThanEstimate\");\r\nvar PasswordsDontMatchError = createCustomErrorClass(\"PasswordsDontMatch\");\r\nvar PasswordIncorrectError = createCustomErrorClass(\"PasswordIncorrect\");\r\nvar RecommendSubAccountsToEmpty = createCustomErrorClass(\"RecommendSubAccountsToEmpty\");\r\nvar RecommendUndelegation = createCustomErrorClass(\"RecommendUndelegation\");\r\nvar TimeoutTagged = createCustomErrorClass(\"TimeoutTagged\");\r\nvar UnexpectedBootloader = createCustomErrorClass(\"UnexpectedBootloader\");\r\nvar MCUNotGenuineToDashboard = createCustomErrorClass(\"MCUNotGenuineToDashboard\");\r\nvar RecipientRequired = createCustomErrorClass(\"RecipientRequired\");\r\nvar UnavailableTezosOriginatedAccountReceive = createCustomErrorClass(\"UnavailableTezosOriginatedAccountReceive\");\r\nvar UnavailableTezosOriginatedAccountSend = createCustomErrorClass(\"UnavailableTezosOriginatedAccountSend\");\r\nvar UpdateFetchFileFail = createCustomErrorClass(\"UpdateFetchFileFail\");\r\nvar UpdateIncorrectHash = createCustomErrorClass(\"UpdateIncorrectHash\");\r\nvar UpdateIncorrectSig = createCustomErrorClass(\"UpdateIncorrectSig\");\r\nvar UpdateYourApp = createCustomErrorClass(\"UpdateYourApp\");\r\nvar UserRefusedDeviceNameChange = createCustomErrorClass(\"UserRefusedDeviceNameChange\");\r\nvar UserRefusedAddress = createCustomErrorClass(\"UserRefusedAddress\");\r\nvar UserRefusedFirmwareUpdate = createCustomErrorClass(\"UserRefusedFirmwareUpdate\");\r\nvar UserRefusedAllowManager = createCustomErrorClass(\"UserRefusedAllowManager\");\r\nvar UserRefusedOnDevice = createCustomErrorClass(\"UserRefusedOnDevice\"); // TODO rename because it's just for transaction refusal\r\nvar TransportOpenUserCancelled = createCustomErrorClass(\"TransportOpenUserCancelled\");\r\nvar TransportInterfaceNotAvailable = createCustomErrorClass(\"TransportInterfaceNotAvailable\");\r\nvar TransportRaceCondition = createCustomErrorClass(\"TransportRaceCondition\");\r\nvar TransportWebUSBGestureRequired = createCustomErrorClass(\"TransportWebUSBGestureRequired\");\r\nvar DeviceShouldStayInApp = createCustomErrorClass(\"DeviceShouldStayInApp\");\r\nvar WebsocketConnectionError = createCustomErrorClass(\"WebsocketConnectionError\");\r\nvar WebsocketConnectionFailed = createCustomErrorClass(\"WebsocketConnectionFailed\");\r\nvar WrongDeviceForAccount = createCustomErrorClass(\"WrongDeviceForAccount\");\r\nvar WrongAppForCurrency = createCustomErrorClass(\"WrongAppForCurrency\");\r\nvar ETHAddressNonEIP = createCustomErrorClass(\"ETHAddressNonEIP\");\r\nvar CantScanQRCode = createCustomErrorClass(\"CantScanQRCode\");\r\nvar FeeNotLoaded = createCustomErrorClass(\"FeeNotLoaded\");\r\nvar FeeRequired = createCustomErrorClass(\"FeeRequired\");\r\nvar FeeTooHigh = createCustomErrorClass(\"FeeTooHigh\");\r\nvar SyncError = createCustomErrorClass(\"SyncError\");\r\nvar PairingFailed = createCustomErrorClass(\"PairingFailed\");\r\nvar GenuineCheckFailed = createCustomErrorClass(\"GenuineCheckFailed\");\r\nvar LedgerAPI4xx = createCustomErrorClass(\"LedgerAPI4xx\");\r\nvar LedgerAPI5xx = createCustomErrorClass(\"LedgerAPI5xx\");\r\nvar FirmwareOrAppUpdateRequired = createCustomErrorClass(\"FirmwareOrAppUpdateRequired\");\r\n// db stuff, no need to translate\r\nvar NoDBPathGiven = createCustomErrorClass(\"NoDBPathGiven\");\r\nvar DBWrongPassword = createCustomErrorClass(\"DBWrongPassword\");\r\nvar DBNotReset = createCustomErrorClass(\"DBNotReset\");\r\n/**\r\n * TransportError is used for any generic transport errors.\r\n * e.g. Error thrown when data received by exchanges are incorrect or if exchanged failed to communicate with the device for various reason.\r\n */\r\nfunction TransportError(message, id) {\r\n    this.name = \"TransportError\";\r\n    this.message = message;\r\n    this.stack = new Error().stack;\r\n    this.id = id;\r\n}\r\nTransportError.prototype = new Error();\r\naddCustomErrorDeserializer(\"TransportError\", function (e) { return new TransportError(e.message, e.id); });\r\nvar StatusCodes = {\r\n    PIN_REMAINING_ATTEMPTS: 0x63c0,\r\n    INCORRECT_LENGTH: 0x6700,\r\n    MISSING_CRITICAL_PARAMETER: 0x6800,\r\n    COMMAND_INCOMPATIBLE_FILE_STRUCTURE: 0x6981,\r\n    SECURITY_STATUS_NOT_SATISFIED: 0x6982,\r\n    CONDITIONS_OF_USE_NOT_SATISFIED: 0x6985,\r\n    INCORRECT_DATA: 0x6a80,\r\n    NOT_ENOUGH_MEMORY_SPACE: 0x6a84,\r\n    REFERENCED_DATA_NOT_FOUND: 0x6a88,\r\n    FILE_ALREADY_EXISTS: 0x6a89,\r\n    INCORRECT_P1_P2: 0x6b00,\r\n    INS_NOT_SUPPORTED: 0x6d00,\r\n    CLA_NOT_SUPPORTED: 0x6e00,\r\n    TECHNICAL_PROBLEM: 0x6f00,\r\n    OK: 0x9000,\r\n    MEMORY_PROBLEM: 0x9240,\r\n    NO_EF_SELECTED: 0x9400,\r\n    INVALID_OFFSET: 0x9402,\r\n    FILE_NOT_FOUND: 0x9404,\r\n    INCONSISTENT_FILE: 0x9408,\r\n    ALGORITHM_NOT_SUPPORTED: 0x9484,\r\n    INVALID_KCV: 0x9485,\r\n    CODE_NOT_INITIALIZED: 0x9802,\r\n    ACCESS_CONDITION_NOT_FULFILLED: 0x9804,\r\n    CONTRADICTION_SECRET_CODE_STATUS: 0x9808,\r\n    CONTRADICTION_INVALIDATION: 0x9810,\r\n    CODE_BLOCKED: 0x9840,\r\n    MAX_VALUE_REACHED: 0x9850,\r\n    GP_AUTH_FAILED: 0x6300,\r\n    LICENSING: 0x6f42,\r\n    HALTED: 0x6faa,\r\n};\r\nfunction getAltStatusMessage(code) {\r\n    switch (code) {\r\n        // improve text of most common errors\r\n        case 0x6700:\r\n            return \"Incorrect length\";\r\n        case 0x6800:\r\n            return \"Missing critical parameter\";\r\n        case 0x6982:\r\n            return \"Security not satisfied (dongle locked or have invalid access rights)\";\r\n        case 0x6985:\r\n            return \"Condition of use not satisfied (denied by the user?)\";\r\n        case 0x6a80:\r\n            return \"Invalid data received\";\r\n        case 0x6b00:\r\n            return \"Invalid parameter received\";\r\n    }\r\n    if (0x6f00 <= code && code <= 0x6fff) {\r\n        return \"Internal error, please report\";\r\n    }\r\n}\r\n/**\r\n * Error thrown when a device returned a non success status.\r\n * the error.statusCode is one of the `StatusCodes` exported by this library.\r\n */\r\nfunction TransportStatusError(statusCode) {\r\n    this.name = \"TransportStatusError\";\r\n    var statusText = Object.keys(StatusCodes).find(function (k) { return StatusCodes[k] === statusCode; }) ||\r\n        \"UNKNOWN_ERROR\";\r\n    var smsg = getAltStatusMessage(statusCode) || statusText;\r\n    var statusCodeStr = statusCode.toString(16);\r\n    this.message = \"Ledger device: \" + smsg + \" (0x\" + statusCodeStr + \")\";\r\n    this.stack = new Error().stack;\r\n    this.statusCode = statusCode;\r\n    this.statusText = statusText;\r\n}\r\nTransportStatusError.prototype = new Error();\r\naddCustomErrorDeserializer(\"TransportStatusError\", function (e) { return new TransportStatusError(e.statusCode); });\n\nexport { AccountNameRequiredError, AccountNotSupported, AmountRequired, BluetoothRequired, BtcUnmatchedApp, CantOpenDevice, CantScanQRCode, CashAddrNotSupported, CurrencyNotSupported, DBNotReset, DBWrongPassword, DeviceAppVerifyNotSupported, DeviceGenuineSocketEarlyClose, DeviceHalted, DeviceInOSUExpected, DeviceNameInvalid, DeviceNotGenuineError, DeviceOnDashboardExpected, DeviceOnDashboardUnexpected, DeviceShouldStayInApp, DeviceSocketFail, DeviceSocketNoBulkStatus, DisconnectedDevice, DisconnectedDeviceDuringOperation, ETHAddressNonEIP, EnpointConfigError, EthAppPleaseEnableContractData, FeeEstimationFailed, FeeNotLoaded, FeeRequired, FeeTooHigh, FirmwareNotRecognized, FirmwareOrAppUpdateRequired, GasLessThanEstimate, GenuineCheckFailed, HardResetFail, InvalidAddress, InvalidAddressBecauseDestinationIsAlsoSource, InvalidXRPTag, LatestMCUInstalledError, LedgerAPI4xx, LedgerAPI5xx, LedgerAPIError, LedgerAPIErrorWithMessage, LedgerAPINotAvailable, MCUNotGenuineToDashboard, ManagerAppAlreadyInstalledError, ManagerAppDepInstallRequired, ManagerAppDepUninstallRequired, ManagerAppRelyOnBTCError, ManagerDeviceLockedError, ManagerFirmwareNotEnoughSpaceError, ManagerNotEnoughSpaceError, ManagerUninstallBTCDep, NetworkDown, NoAccessToCamera, NoAddressesFound, NoDBPathGiven, NotEnoughBalance, NotEnoughBalanceBecauseDestinationNotCreated, NotEnoughBalanceInParentAccount, NotEnoughBalanceToDelegate, NotEnoughGas, NotEnoughSpendableBalance, NotSupportedLegacyAddress, PairingFailed, PasswordIncorrectError, PasswordsDontMatchError, RecipientRequired, RecommendSubAccountsToEmpty, RecommendUndelegation, StatusCodes, SyncError, TimeoutTagged, TransportError, TransportInterfaceNotAvailable, TransportOpenUserCancelled, TransportRaceCondition, TransportStatusError, TransportWebUSBGestureRequired, UnavailableTezosOriginatedAccountReceive, UnavailableTezosOriginatedAccountSend, UnexpectedBootloader, UnknownMCU, UpdateFetchFileFail, UpdateIncorrectHash, UpdateIncorrectSig, UpdateYourApp, UserRefusedAddress, UserRefusedAllowManager, UserRefusedDeviceNameChange, UserRefusedFirmwareUpdate, UserRefusedOnDevice, WebsocketConnectionError, WebsocketConnectionFailed, WrongAppForCurrency, WrongDeviceForAccount, addCustomErrorDeserializer, createCustomErrorClass, deserializeError, getAltStatusMessage, serializeError };\n"],"sourceRoot":""}