{"version":3,"sources":["../../../../src/internal/operators/refCount.ts","../../../../src/internal/operators/groupBy.ts","../../../src/internal/ReplaySubject.ts","../../../../src/internal/observable/throwError.ts","../../../../src/internal/util/noop.ts","../../../../src/internal/observable/combineLatest.ts","../../../../src/internal/observable/defer.ts","../../../../src/internal/observable/zip.ts","../../../../src/internal/util/Immediate.ts","../../../../src/internal/scheduler/AsapAction.ts","../../../../src/internal/scheduler/AsapScheduler.ts","../../../../src/internal/scheduler/asap.ts","../../../../src/internal/scheduler/QueueAction.ts","../../../../src/internal/scheduler/QueueScheduler.ts","../../../../src/internal/scheduler/queue.ts","../../../../src/internal/observable/ConnectableObservable.ts","../../../src/internal/BehaviorSubject.ts","../../../../src/internal/operators/observeOn.ts","../../../../src/internal/util/TimeoutError.ts","../../../../src/internal/operators/concatAll.ts","../../../../src/internal/observable/race.ts","../../../../src/internal/util/not.ts","../../../../src/internal/scheduler/AnimationFrameAction.ts","../../../../src/internal/scheduler/AnimationFrameScheduler.ts","../../../../src/internal/scheduler/animationFrame.ts","../../../../src/internal/scheduler/VirtualTimeScheduler.ts","../../../../src/internal/util/isObservable.ts","../../../../src/internal/observable/bindCallback.ts","../../../../src/internal/observable/bindNodeCallback.ts","../../../../src/internal/observable/forkJoin.ts","../../../../src/internal/observable/fromEventPattern.ts","../../../../src/internal/observable/generate.ts","../../../../src/internal/observable/iif.ts","../../../../src/internal/observable/interval.ts","../../../../src/internal/observable/never.ts","../../../../src/internal/observable/onErrorResumeNext.ts","../../../../src/internal/observable/pairs.ts","../../../../src/internal/observable/partition.ts","../../../../src/internal/observable/range.ts","../../../../src/internal/observable/using.ts","../../../../src/internal/observable/empty.ts","../../../src/internal/OuterSubscriber.ts","../../../../src/internal/operators/filter.ts","../../../src/internal/InnerSubscriber.ts","../../../../src/internal/util/subscribeToResult.ts","../../../src/internal/Notification.ts","../../../../src/internal/util/ArgumentOutOfRangeError.ts","../../../../src/internal/util/EmptyError.ts","../../../../src/internal/observable/of.ts","../../../src/internal/AsyncSubject.ts","../../../../src/internal/observable/concat.ts"],"names":["this","i","action","delay","notPred","schedule","InnerSubscriber","subscriber","AsyncSubject"],"mappings":"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","file":"static/js/5.04e28543.chunk.js","sourcesContent":["/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subscriber } from '../Subscriber';\nexport function refCount() {\n    return function refCountOperatorFunction(source) {\n        return source.lift(new RefCountOperator(source));\n    };\n}\nvar RefCountOperator = /*@__PURE__*/ (function () {\n    function RefCountOperator(connectable) {\n        this.connectable = connectable;\n    }\n    RefCountOperator.prototype.call = function (subscriber, source) {\n        var connectable = this.connectable;\n        connectable._refCount++;\n        var refCounter = new RefCountSubscriber(subscriber, connectable);\n        var subscription = source.subscribe(refCounter);\n        if (!refCounter.closed) {\n            refCounter.connection = connectable.connect();\n        }\n        return subscription;\n    };\n    return RefCountOperator;\n}());\nvar RefCountSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(RefCountSubscriber, _super);\n    function RefCountSubscriber(destination, connectable) {\n        var _this = _super.call(this, destination) || this;\n        _this.connectable = connectable;\n        return _this;\n    }\n    RefCountSubscriber.prototype._unsubscribe = function () {\n        var connectable = this.connectable;\n        if (!connectable) {\n            this.connection = null;\n            return;\n        }\n        this.connectable = null;\n        var refCount = connectable._refCount;\n        if (refCount <= 0) {\n            this.connection = null;\n            return;\n        }\n        connectable._refCount = refCount - 1;\n        if (refCount > 1) {\n            this.connection = null;\n            return;\n        }\n        var connection = this.connection;\n        var sharedConnection = connectable._connection;\n        this.connection = null;\n        if (sharedConnection && (!connection || sharedConnection === connection)) {\n            sharedConnection.unsubscribe();\n        }\n    };\n    return RefCountSubscriber;\n}(Subscriber));\n//# sourceMappingURL=refCount.js.map\n","/** PURE_IMPORTS_START tslib,_Subscriber,_Subscription,_Observable,_Subject PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { Observable } from '../Observable';\nimport { Subject } from '../Subject';\nexport function groupBy(keySelector, elementSelector, durationSelector, subjectSelector) {\n    return function (source) {\n        return source.lift(new GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector));\n    };\n}\nvar GroupByOperator = /*@__PURE__*/ (function () {\n    function GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector) {\n        this.keySelector = keySelector;\n        this.elementSelector = elementSelector;\n        this.durationSelector = durationSelector;\n        this.subjectSelector = subjectSelector;\n    }\n    GroupByOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new GroupBySubscriber(subscriber, this.keySelector, this.elementSelector, this.durationSelector, this.subjectSelector));\n    };\n    return GroupByOperator;\n}());\nvar GroupBySubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(GroupBySubscriber, _super);\n    function GroupBySubscriber(destination, keySelector, elementSelector, durationSelector, subjectSelector) {\n        var _this = _super.call(this, destination) || this;\n        _this.keySelector = keySelector;\n        _this.elementSelector = elementSelector;\n        _this.durationSelector = durationSelector;\n        _this.subjectSelector = subjectSelector;\n        _this.groups = null;\n        _this.attemptedToUnsubscribe = false;\n        _this.count = 0;\n        return _this;\n    }\n    GroupBySubscriber.prototype._next = function (value) {\n        var key;\n        try {\n            key = this.keySelector(value);\n        }\n        catch (err) {\n            this.error(err);\n            return;\n        }\n        this._group(value, key);\n    };\n    GroupBySubscriber.prototype._group = function (value, key) {\n        var groups = this.groups;\n        if (!groups) {\n            groups = this.groups = new Map();\n        }\n        var group = groups.get(key);\n        var element;\n        if (this.elementSelector) {\n            try {\n                element = this.elementSelector(value);\n            }\n            catch (err) {\n                this.error(err);\n            }\n        }\n        else {\n            element = value;\n        }\n        if (!group) {\n            group = (this.subjectSelector ? this.subjectSelector() : new Subject());\n            groups.set(key, group);\n            var groupedObservable = new GroupedObservable(key, group, this);\n            this.destination.next(groupedObservable);\n            if (this.durationSelector) {\n                var duration = void 0;\n                try {\n                    duration = this.durationSelector(new GroupedObservable(key, group));\n                }\n                catch (err) {\n                    this.error(err);\n                    return;\n                }\n                this.add(duration.subscribe(new GroupDurationSubscriber(key, group, this)));\n            }\n        }\n        if (!group.closed) {\n            group.next(element);\n        }\n    };\n    GroupBySubscriber.prototype._error = function (err) {\n        var groups = this.groups;\n        if (groups) {\n            groups.forEach(function (group, key) {\n                group.error(err);\n            });\n            groups.clear();\n        }\n        this.destination.error(err);\n    };\n    GroupBySubscriber.prototype._complete = function () {\n        var groups = this.groups;\n        if (groups) {\n            groups.forEach(function (group, key) {\n                group.complete();\n            });\n            groups.clear();\n        }\n        this.destination.complete();\n    };\n    GroupBySubscriber.prototype.removeGroup = function (key) {\n        this.groups.delete(key);\n    };\n    GroupBySubscriber.prototype.unsubscribe = function () {\n        if (!this.closed) {\n            this.attemptedToUnsubscribe = true;\n            if (this.count === 0) {\n                _super.prototype.unsubscribe.call(this);\n            }\n        }\n    };\n    return GroupBySubscriber;\n}(Subscriber));\nvar GroupDurationSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(GroupDurationSubscriber, _super);\n    function GroupDurationSubscriber(key, group, parent) {\n        var _this = _super.call(this, group) || this;\n        _this.key = key;\n        _this.group = group;\n        _this.parent = parent;\n        return _this;\n    }\n    GroupDurationSubscriber.prototype._next = function (value) {\n        this.complete();\n    };\n    GroupDurationSubscriber.prototype._unsubscribe = function () {\n        var _a = this, parent = _a.parent, key = _a.key;\n        this.key = this.parent = null;\n        if (parent) {\n            parent.removeGroup(key);\n        }\n    };\n    return GroupDurationSubscriber;\n}(Subscriber));\nvar GroupedObservable = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(GroupedObservable, _super);\n    function GroupedObservable(key, groupSubject, refCountSubscription) {\n        var _this = _super.call(this) || this;\n        _this.key = key;\n        _this.groupSubject = groupSubject;\n        _this.refCountSubscription = refCountSubscription;\n        return _this;\n    }\n    GroupedObservable.prototype._subscribe = function (subscriber) {\n        var subscription = new Subscription();\n        var _a = this, refCountSubscription = _a.refCountSubscription, groupSubject = _a.groupSubject;\n        if (refCountSubscription && !refCountSubscription.closed) {\n            subscription.add(new InnerRefCountSubscription(refCountSubscription));\n        }\n        subscription.add(groupSubject.subscribe(subscriber));\n        return subscription;\n    };\n    return GroupedObservable;\n}(Observable));\nexport { GroupedObservable };\nvar InnerRefCountSubscription = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(InnerRefCountSubscription, _super);\n    function InnerRefCountSubscription(parent) {\n        var _this = _super.call(this) || this;\n        _this.parent = parent;\n        parent.count++;\n        return _this;\n    }\n    InnerRefCountSubscription.prototype.unsubscribe = function () {\n        var parent = this.parent;\n        if (!parent.closed && !this.closed) {\n            _super.prototype.unsubscribe.call(this);\n            parent.count -= 1;\n            if (parent.count === 0 && parent.attemptedToUnsubscribe) {\n                parent.unsubscribe();\n            }\n        }\n    };\n    return InnerRefCountSubscription;\n}(Subscription));\n//# sourceMappingURL=groupBy.js.map\n","/** PURE_IMPORTS_START tslib,_Subject,_scheduler_queue,_Subscription,_operators_observeOn,_util_ObjectUnsubscribedError,_SubjectSubscription PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subject } from './Subject';\nimport { queue } from './scheduler/queue';\nimport { Subscription } from './Subscription';\nimport { ObserveOnSubscriber } from './operators/observeOn';\nimport { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError';\nimport { SubjectSubscription } from './SubjectSubscription';\nvar ReplaySubject = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(ReplaySubject, _super);\n    function ReplaySubject(bufferSize, windowTime, scheduler) {\n        if (bufferSize === void 0) {\n            bufferSize = Number.POSITIVE_INFINITY;\n        }\n        if (windowTime === void 0) {\n            windowTime = Number.POSITIVE_INFINITY;\n        }\n        var _this = _super.call(this) || this;\n        _this.scheduler = scheduler;\n        _this._events = [];\n        _this._infiniteTimeWindow = false;\n        _this._bufferSize = bufferSize < 1 ? 1 : bufferSize;\n        _this._windowTime = windowTime < 1 ? 1 : windowTime;\n        if (windowTime === Number.POSITIVE_INFINITY) {\n            _this._infiniteTimeWindow = true;\n            _this.next = _this.nextInfiniteTimeWindow;\n        }\n        else {\n            _this.next = _this.nextTimeWindow;\n        }\n        return _this;\n    }\n    ReplaySubject.prototype.nextInfiniteTimeWindow = function (value) {\n        if (!this.isStopped) {\n            var _events = this._events;\n            _events.push(value);\n            if (_events.length > this._bufferSize) {\n                _events.shift();\n            }\n        }\n        _super.prototype.next.call(this, value);\n    };\n    ReplaySubject.prototype.nextTimeWindow = function (value) {\n        if (!this.isStopped) {\n            this._events.push(new ReplayEvent(this._getNow(), value));\n            this._trimBufferThenGetEvents();\n        }\n        _super.prototype.next.call(this, value);\n    };\n    ReplaySubject.prototype._subscribe = function (subscriber) {\n        var _infiniteTimeWindow = this._infiniteTimeWindow;\n        var _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();\n        var scheduler = this.scheduler;\n        var len = _events.length;\n        var subscription;\n        if (this.closed) {\n            throw new ObjectUnsubscribedError();\n        }\n        else if (this.isStopped || this.hasError) {\n            subscription = Subscription.EMPTY;\n        }\n        else {\n            this.observers.push(subscriber);\n            subscription = new SubjectSubscription(this, subscriber);\n        }\n        if (scheduler) {\n            subscriber.add(subscriber = new ObserveOnSubscriber(subscriber, scheduler));\n        }\n        if (_infiniteTimeWindow) {\n            for (var i = 0; i < len && !subscriber.closed; i++) {\n                subscriber.next(_events[i]);\n            }\n        }\n        else {\n            for (var i = 0; i < len && !subscriber.closed; i++) {\n                subscriber.next(_events[i].value);\n            }\n        }\n        if (this.hasError) {\n            subscriber.error(this.thrownError);\n        }\n        else if (this.isStopped) {\n            subscriber.complete();\n        }\n        return subscription;\n    };\n    ReplaySubject.prototype._getNow = function () {\n        return (this.scheduler || queue).now();\n    };\n    ReplaySubject.prototype._trimBufferThenGetEvents = function () {\n        var now = this._getNow();\n        var _bufferSize = this._bufferSize;\n        var _windowTime = this._windowTime;\n        var _events = this._events;\n        var eventsCount = _events.length;\n        var spliceCount = 0;\n        while (spliceCount < eventsCount) {\n            if ((now - _events[spliceCount].time) < _windowTime) {\n                break;\n            }\n            spliceCount++;\n        }\n        if (eventsCount > _bufferSize) {\n            spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);\n        }\n        if (spliceCount > 0) {\n            _events.splice(0, spliceCount);\n        }\n        return _events;\n    };\n    return ReplaySubject;\n}(Subject));\nexport { ReplaySubject };\nvar ReplayEvent = /*@__PURE__*/ (function () {\n    function ReplayEvent(time, value) {\n        this.time = time;\n        this.value = value;\n    }\n    return ReplayEvent;\n}());\n//# sourceMappingURL=ReplaySubject.js.map\n","/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */\nimport { Observable } from '../Observable';\nexport function throwError(error, scheduler) {\n    if (!scheduler) {\n        return new Observable(function (subscriber) { return subscriber.error(error); });\n    }\n    else {\n        return new Observable(function (subscriber) { return scheduler.schedule(dispatch, 0, { error: error, subscriber: subscriber }); });\n    }\n}\nfunction dispatch(_a) {\n    var error = _a.error, subscriber = _a.subscriber;\n    subscriber.error(error);\n}\n//# sourceMappingURL=throwError.js.map\n","/** PURE_IMPORTS_START  PURE_IMPORTS_END */\nexport function noop() { }\n//# sourceMappingURL=noop.js.map\n","/** PURE_IMPORTS_START tslib,_util_isScheduler,_util_isArray,_OuterSubscriber,_util_subscribeToResult,_fromArray PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { isScheduler } from '../util/isScheduler';\nimport { isArray } from '../util/isArray';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { fromArray } from './fromArray';\nvar NONE = {};\nexport function combineLatest() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i] = arguments[_i];\n    }\n    var resultSelector = undefined;\n    var scheduler = undefined;\n    if (isScheduler(observables[observables.length - 1])) {\n        scheduler = observables.pop();\n    }\n    if (typeof observables[observables.length - 1] === 'function') {\n        resultSelector = observables.pop();\n    }\n    if (observables.length === 1 && isArray(observables[0])) {\n        observables = observables[0];\n    }\n    return fromArray(observables, scheduler).lift(new CombineLatestOperator(resultSelector));\n}\nvar CombineLatestOperator = /*@__PURE__*/ (function () {\n    function CombineLatestOperator(resultSelector) {\n        this.resultSelector = resultSelector;\n    }\n    CombineLatestOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new CombineLatestSubscriber(subscriber, this.resultSelector));\n    };\n    return CombineLatestOperator;\n}());\nexport { CombineLatestOperator };\nvar CombineLatestSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(CombineLatestSubscriber, _super);\n    function CombineLatestSubscriber(destination, resultSelector) {\n        var _this = _super.call(this, destination) || this;\n        _this.resultSelector = resultSelector;\n        _this.active = 0;\n        _this.values = [];\n        _this.observables = [];\n        return _this;\n    }\n    CombineLatestSubscriber.prototype._next = function (observable) {\n        this.values.push(NONE);\n        this.observables.push(observable);\n    };\n    CombineLatestSubscriber.prototype._complete = function () {\n        var observables = this.observables;\n        var len = observables.length;\n        if (len === 0) {\n            this.destination.complete();\n        }\n        else {\n            this.active = len;\n            this.toRespond = len;\n            for (var i = 0; i < len; i++) {\n                var observable = observables[i];\n                this.add(subscribeToResult(this, observable, undefined, i));\n            }\n        }\n    };\n    CombineLatestSubscriber.prototype.notifyComplete = function (unused) {\n        if ((this.active -= 1) === 0) {\n            this.destination.complete();\n        }\n    };\n    CombineLatestSubscriber.prototype.notifyNext = function (_outerValue, innerValue, outerIndex) {\n        var values = this.values;\n        var oldVal = values[outerIndex];\n        var toRespond = !this.toRespond\n            ? 0\n            : oldVal === NONE ? --this.toRespond : this.toRespond;\n        values[outerIndex] = innerValue;\n        if (toRespond === 0) {\n            if (this.resultSelector) {\n                this._tryResultSelector(values);\n            }\n            else {\n                this.destination.next(values.slice());\n            }\n        }\n    };\n    CombineLatestSubscriber.prototype._tryResultSelector = function (values) {\n        var result;\n        try {\n            result = this.resultSelector.apply(this, values);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.destination.next(result);\n    };\n    return CombineLatestSubscriber;\n}(OuterSubscriber));\nexport { CombineLatestSubscriber };\n//# sourceMappingURL=combineLatest.js.map\n","/** PURE_IMPORTS_START _Observable,_from,_empty PURE_IMPORTS_END */\nimport { Observable } from '../Observable';\nimport { from } from './from';\nimport { empty } from './empty';\nexport function defer(observableFactory) {\n    return new Observable(function (subscriber) {\n        var input;\n        try {\n            input = observableFactory();\n        }\n        catch (err) {\n            subscriber.error(err);\n            return undefined;\n        }\n        var source = input ? from(input) : empty();\n        return source.subscribe(subscriber);\n    });\n}\n//# sourceMappingURL=defer.js.map\n","/** PURE_IMPORTS_START tslib,_fromArray,_util_isArray,_Subscriber,_.._internal_symbol_iterator,_innerSubscribe PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { fromArray } from './fromArray';\nimport { isArray } from '../util/isArray';\nimport { Subscriber } from '../Subscriber';\nimport { iterator as Symbol_iterator } from '../../internal/symbol/iterator';\nimport { SimpleOuterSubscriber, SimpleInnerSubscriber, innerSubscribe } from '../innerSubscribe';\nexport function zip() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i] = arguments[_i];\n    }\n    var resultSelector = observables[observables.length - 1];\n    if (typeof resultSelector === 'function') {\n        observables.pop();\n    }\n    return fromArray(observables, undefined).lift(new ZipOperator(resultSelector));\n}\nvar ZipOperator = /*@__PURE__*/ (function () {\n    function ZipOperator(resultSelector) {\n        this.resultSelector = resultSelector;\n    }\n    ZipOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new ZipSubscriber(subscriber, this.resultSelector));\n    };\n    return ZipOperator;\n}());\nexport { ZipOperator };\nvar ZipSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(ZipSubscriber, _super);\n    function ZipSubscriber(destination, resultSelector, values) {\n        if (values === void 0) {\n            values = Object.create(null);\n        }\n        var _this = _super.call(this, destination) || this;\n        _this.resultSelector = resultSelector;\n        _this.iterators = [];\n        _this.active = 0;\n        _this.resultSelector = (typeof resultSelector === 'function') ? resultSelector : undefined;\n        return _this;\n    }\n    ZipSubscriber.prototype._next = function (value) {\n        var iterators = this.iterators;\n        if (isArray(value)) {\n            iterators.push(new StaticArrayIterator(value));\n        }\n        else if (typeof value[Symbol_iterator] === 'function') {\n            iterators.push(new StaticIterator(value[Symbol_iterator]()));\n        }\n        else {\n            iterators.push(new ZipBufferIterator(this.destination, this, value));\n        }\n    };\n    ZipSubscriber.prototype._complete = function () {\n        var iterators = this.iterators;\n        var len = iterators.length;\n        this.unsubscribe();\n        if (len === 0) {\n            this.destination.complete();\n            return;\n        }\n        this.active = len;\n        for (var i = 0; i < len; i++) {\n            var iterator = iterators[i];\n            if (iterator.stillUnsubscribed) {\n                var destination = this.destination;\n                destination.add(iterator.subscribe());\n            }\n            else {\n                this.active--;\n            }\n        }\n    };\n    ZipSubscriber.prototype.notifyInactive = function () {\n        this.active--;\n        if (this.active === 0) {\n            this.destination.complete();\n        }\n    };\n    ZipSubscriber.prototype.checkIterators = function () {\n        var iterators = this.iterators;\n        var len = iterators.length;\n        var destination = this.destination;\n        for (var i = 0; i < len; i++) {\n            var iterator = iterators[i];\n            if (typeof iterator.hasValue === 'function' && !iterator.hasValue()) {\n                return;\n            }\n        }\n        var shouldComplete = false;\n        var args = [];\n        for (var i = 0; i < len; i++) {\n            var iterator = iterators[i];\n            var result = iterator.next();\n            if (iterator.hasCompleted()) {\n                shouldComplete = true;\n            }\n            if (result.done) {\n                destination.complete();\n                return;\n            }\n            args.push(result.value);\n        }\n        if (this.resultSelector) {\n            this._tryresultSelector(args);\n        }\n        else {\n            destination.next(args);\n        }\n        if (shouldComplete) {\n            destination.complete();\n        }\n    };\n    ZipSubscriber.prototype._tryresultSelector = function (args) {\n        var result;\n        try {\n            result = this.resultSelector.apply(this, args);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.destination.next(result);\n    };\n    return ZipSubscriber;\n}(Subscriber));\nexport { ZipSubscriber };\nvar StaticIterator = /*@__PURE__*/ (function () {\n    function StaticIterator(iterator) {\n        this.iterator = iterator;\n        this.nextResult = iterator.next();\n    }\n    StaticIterator.prototype.hasValue = function () {\n        return true;\n    };\n    StaticIterator.prototype.next = function () {\n        var result = this.nextResult;\n        this.nextResult = this.iterator.next();\n        return result;\n    };\n    StaticIterator.prototype.hasCompleted = function () {\n        var nextResult = this.nextResult;\n        return Boolean(nextResult && nextResult.done);\n    };\n    return StaticIterator;\n}());\nvar StaticArrayIterator = /*@__PURE__*/ (function () {\n    function StaticArrayIterator(array) {\n        this.array = array;\n        this.index = 0;\n        this.length = 0;\n        this.length = array.length;\n    }\n    StaticArrayIterator.prototype[Symbol_iterator] = function () {\n        return this;\n    };\n    StaticArrayIterator.prototype.next = function (value) {\n        var i = this.index++;\n        var array = this.array;\n        return i < this.length ? { value: array[i], done: false } : { value: null, done: true };\n    };\n    StaticArrayIterator.prototype.hasValue = function () {\n        return this.array.length > this.index;\n    };\n    StaticArrayIterator.prototype.hasCompleted = function () {\n        return this.array.length === this.index;\n    };\n    return StaticArrayIterator;\n}());\nvar ZipBufferIterator = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(ZipBufferIterator, _super);\n    function ZipBufferIterator(destination, parent, observable) {\n        var _this = _super.call(this, destination) || this;\n        _this.parent = parent;\n        _this.observable = observable;\n        _this.stillUnsubscribed = true;\n        _this.buffer = [];\n        _this.isComplete = false;\n        return _this;\n    }\n    ZipBufferIterator.prototype[Symbol_iterator] = function () {\n        return this;\n    };\n    ZipBufferIterator.prototype.next = function () {\n        var buffer = this.buffer;\n        if (buffer.length === 0 && this.isComplete) {\n            return { value: null, done: true };\n        }\n        else {\n            return { value: buffer.shift(), done: false };\n        }\n    };\n    ZipBufferIterator.prototype.hasValue = function () {\n        return this.buffer.length > 0;\n    };\n    ZipBufferIterator.prototype.hasCompleted = function () {\n        return this.buffer.length === 0 && this.isComplete;\n    };\n    ZipBufferIterator.prototype.notifyComplete = function () {\n        if (this.buffer.length > 0) {\n            this.isComplete = true;\n            this.parent.notifyInactive();\n        }\n        else {\n            this.destination.complete();\n        }\n    };\n    ZipBufferIterator.prototype.notifyNext = function (innerValue) {\n        this.buffer.push(innerValue);\n        this.parent.checkIterators();\n    };\n    ZipBufferIterator.prototype.subscribe = function () {\n        return innerSubscribe(this.observable, new SimpleInnerSubscriber(this));\n    };\n    return ZipBufferIterator;\n}(SimpleOuterSubscriber));\n//# sourceMappingURL=zip.js.map\n","/** PURE_IMPORTS_START  PURE_IMPORTS_END */\nvar nextHandle = 1;\nvar RESOLVED = /*@__PURE__*/ (function () { return /*@__PURE__*/ Promise.resolve(); })();\nvar activeHandles = {};\nfunction findAndClearHandle(handle) {\n    if (handle in activeHandles) {\n        delete activeHandles[handle];\n        return true;\n    }\n    return false;\n}\nexport var Immediate = {\n    setImmediate: function (cb) {\n        var handle = nextHandle++;\n        activeHandles[handle] = true;\n        RESOLVED.then(function () { return findAndClearHandle(handle) && cb(); });\n        return handle;\n    },\n    clearImmediate: function (handle) {\n        findAndClearHandle(handle);\n    },\n};\nexport var TestTools = {\n    pending: function () {\n        return Object.keys(activeHandles).length;\n    }\n};\n//# sourceMappingURL=Immediate.js.map\n","/** PURE_IMPORTS_START tslib,_util_Immediate,_AsyncAction PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Immediate } from '../util/Immediate';\nimport { AsyncAction } from './AsyncAction';\nvar AsapAction = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(AsapAction, _super);\n    function AsapAction(scheduler, work) {\n        var _this = _super.call(this, scheduler, work) || this;\n        _this.scheduler = scheduler;\n        _this.work = work;\n        return _this;\n    }\n    AsapAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) {\n            delay = 0;\n        }\n        if (delay !== null && delay > 0) {\n            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);\n        }\n        scheduler.actions.push(this);\n        return scheduler.scheduled || (scheduler.scheduled = Immediate.setImmediate(scheduler.flush.bind(scheduler, null)));\n    };\n    AsapAction.prototype.recycleAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) {\n            delay = 0;\n        }\n        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {\n            return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);\n        }\n        if (scheduler.actions.length === 0) {\n            Immediate.clearImmediate(id);\n            scheduler.scheduled = undefined;\n        }\n        return undefined;\n    };\n    return AsapAction;\n}(AsyncAction));\nexport { AsapAction };\n//# sourceMappingURL=AsapAction.js.map\n","/** PURE_IMPORTS_START tslib,_AsyncScheduler PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { AsyncScheduler } from './AsyncScheduler';\nvar AsapScheduler = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(AsapScheduler, _super);\n    function AsapScheduler() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    AsapScheduler.prototype.flush = function (action) {\n        this.active = true;\n        this.scheduled = undefined;\n        var actions = this.actions;\n        var error;\n        var index = -1;\n        var count = actions.length;\n        action = action || actions.shift();\n        do {\n            if (error = action.execute(action.state, action.delay)) {\n                break;\n            }\n        } while (++index < count && (action = actions.shift()));\n        this.active = false;\n        if (error) {\n            while (++index < count && (action = actions.shift())) {\n                action.unsubscribe();\n            }\n            throw error;\n        }\n    };\n    return AsapScheduler;\n}(AsyncScheduler));\nexport { AsapScheduler };\n//# sourceMappingURL=AsapScheduler.js.map\n","/** PURE_IMPORTS_START _AsapAction,_AsapScheduler PURE_IMPORTS_END */\nimport { AsapAction } from './AsapAction';\nimport { AsapScheduler } from './AsapScheduler';\nexport var asapScheduler = /*@__PURE__*/ new AsapScheduler(AsapAction);\nexport var asap = asapScheduler;\n//# sourceMappingURL=asap.js.map\n","/** PURE_IMPORTS_START tslib,_AsyncAction PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { AsyncAction } from './AsyncAction';\nvar QueueAction = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(QueueAction, _super);\n    function QueueAction(scheduler, work) {\n        var _this = _super.call(this, scheduler, work) || this;\n        _this.scheduler = scheduler;\n        _this.work = work;\n        return _this;\n    }\n    QueueAction.prototype.schedule = function (state, delay) {\n        if (delay === void 0) {\n            delay = 0;\n        }\n        if (delay > 0) {\n            return _super.prototype.schedule.call(this, state, delay);\n        }\n        this.delay = delay;\n        this.state = state;\n        this.scheduler.flush(this);\n        return this;\n    };\n    QueueAction.prototype.execute = function (state, delay) {\n        return (delay > 0 || this.closed) ?\n            _super.prototype.execute.call(this, state, delay) :\n            this._execute(state, delay);\n    };\n    QueueAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) {\n            delay = 0;\n        }\n        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {\n            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);\n        }\n        return scheduler.flush(this);\n    };\n    return QueueAction;\n}(AsyncAction));\nexport { QueueAction };\n//# sourceMappingURL=QueueAction.js.map\n","/** PURE_IMPORTS_START tslib,_AsyncScheduler PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { AsyncScheduler } from './AsyncScheduler';\nvar QueueScheduler = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(QueueScheduler, _super);\n    function QueueScheduler() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return QueueScheduler;\n}(AsyncScheduler));\nexport { QueueScheduler };\n//# sourceMappingURL=QueueScheduler.js.map\n","/** PURE_IMPORTS_START _QueueAction,_QueueScheduler PURE_IMPORTS_END */\nimport { QueueAction } from './QueueAction';\nimport { QueueScheduler } from './QueueScheduler';\nexport var queueScheduler = /*@__PURE__*/ new QueueScheduler(QueueAction);\nexport var queue = queueScheduler;\n//# sourceMappingURL=queue.js.map\n","/** PURE_IMPORTS_START tslib,_Subject,_Observable,_Subscriber,_Subscription,_operators_refCount PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { SubjectSubscriber } from '../Subject';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { refCount as higherOrderRefCount } from '../operators/refCount';\nvar ConnectableObservable = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(ConnectableObservable, _super);\n    function ConnectableObservable(source, subjectFactory) {\n        var _this = _super.call(this) || this;\n        _this.source = source;\n        _this.subjectFactory = subjectFactory;\n        _this._refCount = 0;\n        _this._isComplete = false;\n        return _this;\n    }\n    ConnectableObservable.prototype._subscribe = function (subscriber) {\n        return this.getSubject().subscribe(subscriber);\n    };\n    ConnectableObservable.prototype.getSubject = function () {\n        var subject = this._subject;\n        if (!subject || subject.isStopped) {\n            this._subject = this.subjectFactory();\n        }\n        return this._subject;\n    };\n    ConnectableObservable.prototype.connect = function () {\n        var connection = this._connection;\n        if (!connection) {\n            this._isComplete = false;\n            connection = this._connection = new Subscription();\n            connection.add(this.source\n                .subscribe(new ConnectableSubscriber(this.getSubject(), this)));\n            if (connection.closed) {\n                this._connection = null;\n                connection = Subscription.EMPTY;\n            }\n        }\n        return connection;\n    };\n    ConnectableObservable.prototype.refCount = function () {\n        return higherOrderRefCount()(this);\n    };\n    return ConnectableObservable;\n}(Observable));\nexport { ConnectableObservable };\nexport var connectableObservableDescriptor = /*@__PURE__*/ (function () {\n    var connectableProto = ConnectableObservable.prototype;\n    return {\n        operator: { value: null },\n        _refCount: { value: 0, writable: true },\n        _subject: { value: null, writable: true },\n        _connection: { value: null, writable: true },\n        _subscribe: { value: connectableProto._subscribe },\n        _isComplete: { value: connectableProto._isComplete, writable: true },\n        getSubject: { value: connectableProto.getSubject },\n        connect: { value: connectableProto.connect },\n        refCount: { value: connectableProto.refCount }\n    };\n})();\nvar ConnectableSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(ConnectableSubscriber, _super);\n    function ConnectableSubscriber(destination, connectable) {\n        var _this = _super.call(this, destination) || this;\n        _this.connectable = connectable;\n        return _this;\n    }\n    ConnectableSubscriber.prototype._error = function (err) {\n        this._unsubscribe();\n        _super.prototype._error.call(this, err);\n    };\n    ConnectableSubscriber.prototype._complete = function () {\n        this.connectable._isComplete = true;\n        this._unsubscribe();\n        _super.prototype._complete.call(this);\n    };\n    ConnectableSubscriber.prototype._unsubscribe = function () {\n        var connectable = this.connectable;\n        if (connectable) {\n            this.connectable = null;\n            var connection = connectable._connection;\n            connectable._refCount = 0;\n            connectable._subject = null;\n            connectable._connection = null;\n            if (connection) {\n                connection.unsubscribe();\n            }\n        }\n    };\n    return ConnectableSubscriber;\n}(SubjectSubscriber));\nvar RefCountOperator = /*@__PURE__*/ (function () {\n    function RefCountOperator(connectable) {\n        this.connectable = connectable;\n    }\n    RefCountOperator.prototype.call = function (subscriber, source) {\n        var connectable = this.connectable;\n        connectable._refCount++;\n        var refCounter = new RefCountSubscriber(subscriber, connectable);\n        var subscription = source.subscribe(refCounter);\n        if (!refCounter.closed) {\n            refCounter.connection = connectable.connect();\n        }\n        return subscription;\n    };\n    return RefCountOperator;\n}());\nvar RefCountSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(RefCountSubscriber, _super);\n    function RefCountSubscriber(destination, connectable) {\n        var _this = _super.call(this, destination) || this;\n        _this.connectable = connectable;\n        return _this;\n    }\n    RefCountSubscriber.prototype._unsubscribe = function () {\n        var connectable = this.connectable;\n        if (!connectable) {\n            this.connection = null;\n            return;\n        }\n        this.connectable = null;\n        var refCount = connectable._refCount;\n        if (refCount <= 0) {\n            this.connection = null;\n            return;\n        }\n        connectable._refCount = refCount - 1;\n        if (refCount > 1) {\n            this.connection = null;\n            return;\n        }\n        var connection = this.connection;\n        var sharedConnection = connectable._connection;\n        this.connection = null;\n        if (sharedConnection && (!connection || sharedConnection === connection)) {\n            sharedConnection.unsubscribe();\n        }\n    };\n    return RefCountSubscriber;\n}(Subscriber));\n//# sourceMappingURL=ConnectableObservable.js.map\n","/** PURE_IMPORTS_START tslib,_Subject,_util_ObjectUnsubscribedError PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subject } from './Subject';\nimport { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError';\nvar BehaviorSubject = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(BehaviorSubject, _super);\n    function BehaviorSubject(_value) {\n        var _this = _super.call(this) || this;\n        _this._value = _value;\n        return _this;\n    }\n    Object.defineProperty(BehaviorSubject.prototype, \"value\", {\n        get: function () {\n            return this.getValue();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    BehaviorSubject.prototype._subscribe = function (subscriber) {\n        var subscription = _super.prototype._subscribe.call(this, subscriber);\n        if (subscription && !subscription.closed) {\n            subscriber.next(this._value);\n        }\n        return subscription;\n    };\n    BehaviorSubject.prototype.getValue = function () {\n        if (this.hasError) {\n            throw this.thrownError;\n        }\n        else if (this.closed) {\n            throw new ObjectUnsubscribedError();\n        }\n        else {\n            return this._value;\n        }\n    };\n    BehaviorSubject.prototype.next = function (value) {\n        _super.prototype.next.call(this, this._value = value);\n    };\n    return BehaviorSubject;\n}(Subject));\nexport { BehaviorSubject };\n//# sourceMappingURL=BehaviorSubject.js.map\n","/** PURE_IMPORTS_START tslib,_Subscriber,_Notification PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subscriber } from '../Subscriber';\nimport { Notification } from '../Notification';\nexport function observeOn(scheduler, delay) {\n    if (delay === void 0) {\n        delay = 0;\n    }\n    return function observeOnOperatorFunction(source) {\n        return source.lift(new ObserveOnOperator(scheduler, delay));\n    };\n}\nvar ObserveOnOperator = /*@__PURE__*/ (function () {\n    function ObserveOnOperator(scheduler, delay) {\n        if (delay === void 0) {\n            delay = 0;\n        }\n        this.scheduler = scheduler;\n        this.delay = delay;\n    }\n    ObserveOnOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));\n    };\n    return ObserveOnOperator;\n}());\nexport { ObserveOnOperator };\nvar ObserveOnSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(ObserveOnSubscriber, _super);\n    function ObserveOnSubscriber(destination, scheduler, delay) {\n        if (delay === void 0) {\n            delay = 0;\n        }\n        var _this = _super.call(this, destination) || this;\n        _this.scheduler = scheduler;\n        _this.delay = delay;\n        return _this;\n    }\n    ObserveOnSubscriber.dispatch = function (arg) {\n        var notification = arg.notification, destination = arg.destination;\n        notification.observe(destination);\n        this.unsubscribe();\n    };\n    ObserveOnSubscriber.prototype.scheduleMessage = function (notification) {\n        var destination = this.destination;\n        destination.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));\n    };\n    ObserveOnSubscriber.prototype._next = function (value) {\n        this.scheduleMessage(Notification.createNext(value));\n    };\n    ObserveOnSubscriber.prototype._error = function (err) {\n        this.scheduleMessage(Notification.createError(err));\n        this.unsubscribe();\n    };\n    ObserveOnSubscriber.prototype._complete = function () {\n        this.scheduleMessage(Notification.createComplete());\n        this.unsubscribe();\n    };\n    return ObserveOnSubscriber;\n}(Subscriber));\nexport { ObserveOnSubscriber };\nvar ObserveOnMessage = /*@__PURE__*/ (function () {\n    function ObserveOnMessage(notification, destination) {\n        this.notification = notification;\n        this.destination = destination;\n    }\n    return ObserveOnMessage;\n}());\nexport { ObserveOnMessage };\n//# sourceMappingURL=observeOn.js.map\n","/** PURE_IMPORTS_START  PURE_IMPORTS_END */\nvar TimeoutErrorImpl = /*@__PURE__*/ (function () {\n    function TimeoutErrorImpl() {\n        Error.call(this);\n        this.message = 'Timeout has occurred';\n        this.name = 'TimeoutError';\n        return this;\n    }\n    TimeoutErrorImpl.prototype = /*@__PURE__*/ Object.create(Error.prototype);\n    return TimeoutErrorImpl;\n})();\nexport var TimeoutError = TimeoutErrorImpl;\n//# sourceMappingURL=TimeoutError.js.map\n","/** PURE_IMPORTS_START _mergeAll PURE_IMPORTS_END */\nimport { mergeAll } from './mergeAll';\nexport function concatAll() {\n    return mergeAll(1);\n}\n//# sourceMappingURL=concatAll.js.map\n","/** PURE_IMPORTS_START tslib,_util_isArray,_fromArray,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { isArray } from '../util/isArray';\nimport { fromArray } from './fromArray';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nexport function race() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i] = arguments[_i];\n    }\n    if (observables.length === 1) {\n        if (isArray(observables[0])) {\n            observables = observables[0];\n        }\n        else {\n            return observables[0];\n        }\n    }\n    return fromArray(observables, undefined).lift(new RaceOperator());\n}\nvar RaceOperator = /*@__PURE__*/ (function () {\n    function RaceOperator() {\n    }\n    RaceOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new RaceSubscriber(subscriber));\n    };\n    return RaceOperator;\n}());\nexport { RaceOperator };\nvar RaceSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(RaceSubscriber, _super);\n    function RaceSubscriber(destination) {\n        var _this = _super.call(this, destination) || this;\n        _this.hasFirst = false;\n        _this.observables = [];\n        _this.subscriptions = [];\n        return _this;\n    }\n    RaceSubscriber.prototype._next = function (observable) {\n        this.observables.push(observable);\n    };\n    RaceSubscriber.prototype._complete = function () {\n        var observables = this.observables;\n        var len = observables.length;\n        if (len === 0) {\n            this.destination.complete();\n        }\n        else {\n            for (var i = 0; i < len && !this.hasFirst; i++) {\n                var observable = observables[i];\n                var subscription = subscribeToResult(this, observable, undefined, i);\n                if (this.subscriptions) {\n                    this.subscriptions.push(subscription);\n                }\n                this.add(subscription);\n            }\n            this.observables = null;\n        }\n    };\n    RaceSubscriber.prototype.notifyNext = function (_outerValue, innerValue, outerIndex) {\n        if (!this.hasFirst) {\n            this.hasFirst = true;\n            for (var i = 0; i < this.subscriptions.length; i++) {\n                if (i !== outerIndex) {\n                    var subscription = this.subscriptions[i];\n                    subscription.unsubscribe();\n                    this.remove(subscription);\n                }\n            }\n            this.subscriptions = null;\n        }\n        this.destination.next(innerValue);\n    };\n    return RaceSubscriber;\n}(OuterSubscriber));\nexport { RaceSubscriber };\n//# sourceMappingURL=race.js.map\n","/** PURE_IMPORTS_START  PURE_IMPORTS_END */\nexport function not(pred, thisArg) {\n    function notPred() {\n        return !(notPred.pred.apply(notPred.thisArg, arguments));\n    }\n    notPred.pred = pred;\n    notPred.thisArg = thisArg;\n    return notPred;\n}\n//# sourceMappingURL=not.js.map\n","/** PURE_IMPORTS_START tslib,_AsyncAction PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { AsyncAction } from './AsyncAction';\nvar AnimationFrameAction = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(AnimationFrameAction, _super);\n    function AnimationFrameAction(scheduler, work) {\n        var _this = _super.call(this, scheduler, work) || this;\n        _this.scheduler = scheduler;\n        _this.work = work;\n        return _this;\n    }\n    AnimationFrameAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) {\n            delay = 0;\n        }\n        if (delay !== null && delay > 0) {\n            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);\n        }\n        scheduler.actions.push(this);\n        return scheduler.scheduled || (scheduler.scheduled = requestAnimationFrame(function () { return scheduler.flush(null); }));\n    };\n    AnimationFrameAction.prototype.recycleAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) {\n            delay = 0;\n        }\n        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {\n            return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);\n        }\n        if (scheduler.actions.length === 0) {\n            cancelAnimationFrame(id);\n            scheduler.scheduled = undefined;\n        }\n        return undefined;\n    };\n    return AnimationFrameAction;\n}(AsyncAction));\nexport { AnimationFrameAction };\n//# sourceMappingURL=AnimationFrameAction.js.map\n","/** PURE_IMPORTS_START tslib,_AsyncScheduler PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { AsyncScheduler } from './AsyncScheduler';\nvar AnimationFrameScheduler = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(AnimationFrameScheduler, _super);\n    function AnimationFrameScheduler() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    AnimationFrameScheduler.prototype.flush = function (action) {\n        this.active = true;\n        this.scheduled = undefined;\n        var actions = this.actions;\n        var error;\n        var index = -1;\n        var count = actions.length;\n        action = action || actions.shift();\n        do {\n            if (error = action.execute(action.state, action.delay)) {\n                break;\n            }\n        } while (++index < count && (action = actions.shift()));\n        this.active = false;\n        if (error) {\n            while (++index < count && (action = actions.shift())) {\n                action.unsubscribe();\n            }\n            throw error;\n        }\n    };\n    return AnimationFrameScheduler;\n}(AsyncScheduler));\nexport { AnimationFrameScheduler };\n//# sourceMappingURL=AnimationFrameScheduler.js.map\n","/** PURE_IMPORTS_START _AnimationFrameAction,_AnimationFrameScheduler PURE_IMPORTS_END */\nimport { AnimationFrameAction } from './AnimationFrameAction';\nimport { AnimationFrameScheduler } from './AnimationFrameScheduler';\nexport var animationFrameScheduler = /*@__PURE__*/ new AnimationFrameScheduler(AnimationFrameAction);\nexport var animationFrame = animationFrameScheduler;\n//# sourceMappingURL=animationFrame.js.map\n","/** PURE_IMPORTS_START tslib,_AsyncAction,_AsyncScheduler PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { AsyncAction } from './AsyncAction';\nimport { AsyncScheduler } from './AsyncScheduler';\nvar VirtualTimeScheduler = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(VirtualTimeScheduler, _super);\n    function VirtualTimeScheduler(SchedulerAction, maxFrames) {\n        if (SchedulerAction === void 0) {\n            SchedulerAction = VirtualAction;\n        }\n        if (maxFrames === void 0) {\n            maxFrames = Number.POSITIVE_INFINITY;\n        }\n        var _this = _super.call(this, SchedulerAction, function () { return _this.frame; }) || this;\n        _this.maxFrames = maxFrames;\n        _this.frame = 0;\n        _this.index = -1;\n        return _this;\n    }\n    VirtualTimeScheduler.prototype.flush = function () {\n        var _a = this, actions = _a.actions, maxFrames = _a.maxFrames;\n        var error, action;\n        while ((action = actions[0]) && action.delay <= maxFrames) {\n            actions.shift();\n            this.frame = action.delay;\n            if (error = action.execute(action.state, action.delay)) {\n                break;\n            }\n        }\n        if (error) {\n            while (action = actions.shift()) {\n                action.unsubscribe();\n            }\n            throw error;\n        }\n    };\n    VirtualTimeScheduler.frameTimeFactor = 10;\n    return VirtualTimeScheduler;\n}(AsyncScheduler));\nexport { VirtualTimeScheduler };\nvar VirtualAction = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(VirtualAction, _super);\n    function VirtualAction(scheduler, work, index) {\n        if (index === void 0) {\n            index = scheduler.index += 1;\n        }\n        var _this = _super.call(this, scheduler, work) || this;\n        _this.scheduler = scheduler;\n        _this.work = work;\n        _this.index = index;\n        _this.active = true;\n        _this.index = scheduler.index = index;\n        return _this;\n    }\n    VirtualAction.prototype.schedule = function (state, delay) {\n        if (delay === void 0) {\n            delay = 0;\n        }\n        if (!this.id) {\n            return _super.prototype.schedule.call(this, state, delay);\n        }\n        this.active = false;\n        var action = new VirtualAction(this.scheduler, this.work);\n        this.add(action);\n        return action.schedule(state, delay);\n    };\n    VirtualAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) {\n            delay = 0;\n        }\n        this.delay = scheduler.frame + delay;\n        var actions = scheduler.actions;\n        actions.push(this);\n        actions.sort(VirtualAction.sortActions);\n        return true;\n    };\n    VirtualAction.prototype.recycleAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) {\n            delay = 0;\n        }\n        return undefined;\n    };\n    VirtualAction.prototype._execute = function (state, delay) {\n        if (this.active === true) {\n            return _super.prototype._execute.call(this, state, delay);\n        }\n    };\n    VirtualAction.sortActions = function (a, b) {\n        if (a.delay === b.delay) {\n            if (a.index === b.index) {\n                return 0;\n            }\n            else if (a.index > b.index) {\n                return 1;\n            }\n            else {\n                return -1;\n            }\n        }\n        else if (a.delay > b.delay) {\n            return 1;\n        }\n        else {\n            return -1;\n        }\n    };\n    return VirtualAction;\n}(AsyncAction));\nexport { VirtualAction };\n//# sourceMappingURL=VirtualTimeScheduler.js.map\n","/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */\nimport { Observable } from '../Observable';\nexport function isObservable(obj) {\n    return !!obj && (obj instanceof Observable || (typeof obj.lift === 'function' && typeof obj.subscribe === 'function'));\n}\n//# sourceMappingURL=isObservable.js.map\n","/** PURE_IMPORTS_START _Observable,_AsyncSubject,_operators_map,_util_canReportError,_util_isArray,_util_isScheduler PURE_IMPORTS_END */\nimport { Observable } from '../Observable';\nimport { AsyncSubject } from '../AsyncSubject';\nimport { map } from '../operators/map';\nimport { canReportError } from '../util/canReportError';\nimport { isArray } from '../util/isArray';\nimport { isScheduler } from '../util/isScheduler';\nexport function bindCallback(callbackFunc, resultSelector, scheduler) {\n    if (resultSelector) {\n        if (isScheduler(resultSelector)) {\n            scheduler = resultSelector;\n        }\n        else {\n            return function () {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                return bindCallback(callbackFunc, scheduler).apply(void 0, args).pipe(map(function (args) { return isArray(args) ? resultSelector.apply(void 0, args) : resultSelector(args); }));\n            };\n        }\n    }\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        var context = this;\n        var subject;\n        var params = {\n            context: context,\n            subject: subject,\n            callbackFunc: callbackFunc,\n            scheduler: scheduler,\n        };\n        return new Observable(function (subscriber) {\n            if (!scheduler) {\n                if (!subject) {\n                    subject = new AsyncSubject();\n                    var handler = function () {\n                        var innerArgs = [];\n                        for (var _i = 0; _i < arguments.length; _i++) {\n                            innerArgs[_i] = arguments[_i];\n                        }\n                        subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);\n                        subject.complete();\n                    };\n                    try {\n                        callbackFunc.apply(context, args.concat([handler]));\n                    }\n                    catch (err) {\n                        if (canReportError(subject)) {\n                            subject.error(err);\n                        }\n                        else {\n                            console.warn(err);\n                        }\n                    }\n                }\n                return subject.subscribe(subscriber);\n            }\n            else {\n                var state = {\n                    args: args, subscriber: subscriber, params: params,\n                };\n                return scheduler.schedule(dispatch, 0, state);\n            }\n        });\n    };\n}\nfunction dispatch(state) {\n    var _this = this;\n    var self = this;\n    var args = state.args, subscriber = state.subscriber, params = state.params;\n    var callbackFunc = params.callbackFunc, context = params.context, scheduler = params.scheduler;\n    var subject = params.subject;\n    if (!subject) {\n        subject = params.subject = new AsyncSubject();\n        var handler = function () {\n            var innerArgs = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                innerArgs[_i] = arguments[_i];\n            }\n            var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;\n            _this.add(scheduler.schedule(dispatchNext, 0, { value: value, subject: subject }));\n        };\n        try {\n            callbackFunc.apply(context, args.concat([handler]));\n        }\n        catch (err) {\n            subject.error(err);\n        }\n    }\n    this.add(subject.subscribe(subscriber));\n}\nfunction dispatchNext(state) {\n    var value = state.value, subject = state.subject;\n    subject.next(value);\n    subject.complete();\n}\nfunction dispatchError(state) {\n    var err = state.err, subject = state.subject;\n    subject.error(err);\n}\n//# sourceMappingURL=bindCallback.js.map\n","/** PURE_IMPORTS_START _Observable,_AsyncSubject,_operators_map,_util_canReportError,_util_isScheduler,_util_isArray PURE_IMPORTS_END */\nimport { Observable } from '../Observable';\nimport { AsyncSubject } from '../AsyncSubject';\nimport { map } from '../operators/map';\nimport { canReportError } from '../util/canReportError';\nimport { isScheduler } from '../util/isScheduler';\nimport { isArray } from '../util/isArray';\nexport function bindNodeCallback(callbackFunc, resultSelector, scheduler) {\n    if (resultSelector) {\n        if (isScheduler(resultSelector)) {\n            scheduler = resultSelector;\n        }\n        else {\n            return function () {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                return bindNodeCallback(callbackFunc, scheduler).apply(void 0, args).pipe(map(function (args) { return isArray(args) ? resultSelector.apply(void 0, args) : resultSelector(args); }));\n            };\n        }\n    }\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        var params = {\n            subject: undefined,\n            args: args,\n            callbackFunc: callbackFunc,\n            scheduler: scheduler,\n            context: this,\n        };\n        return new Observable(function (subscriber) {\n            var context = params.context;\n            var subject = params.subject;\n            if (!scheduler) {\n                if (!subject) {\n                    subject = params.subject = new AsyncSubject();\n                    var handler = function () {\n                        var innerArgs = [];\n                        for (var _i = 0; _i < arguments.length; _i++) {\n                            innerArgs[_i] = arguments[_i];\n                        }\n                        var err = innerArgs.shift();\n                        if (err) {\n                            subject.error(err);\n                            return;\n                        }\n                        subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);\n                        subject.complete();\n                    };\n                    try {\n                        callbackFunc.apply(context, args.concat([handler]));\n                    }\n                    catch (err) {\n                        if (canReportError(subject)) {\n                            subject.error(err);\n                        }\n                        else {\n                            console.warn(err);\n                        }\n                    }\n                }\n                return subject.subscribe(subscriber);\n            }\n            else {\n                return scheduler.schedule(dispatch, 0, { params: params, subscriber: subscriber, context: context });\n            }\n        });\n    };\n}\nfunction dispatch(state) {\n    var _this = this;\n    var params = state.params, subscriber = state.subscriber, context = state.context;\n    var callbackFunc = params.callbackFunc, args = params.args, scheduler = params.scheduler;\n    var subject = params.subject;\n    if (!subject) {\n        subject = params.subject = new AsyncSubject();\n        var handler = function () {\n            var innerArgs = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                innerArgs[_i] = arguments[_i];\n            }\n            var err = innerArgs.shift();\n            if (err) {\n                _this.add(scheduler.schedule(dispatchError, 0, { err: err, subject: subject }));\n            }\n            else {\n                var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;\n                _this.add(scheduler.schedule(dispatchNext, 0, { value: value, subject: subject }));\n            }\n        };\n        try {\n            callbackFunc.apply(context, args.concat([handler]));\n        }\n        catch (err) {\n            this.add(scheduler.schedule(dispatchError, 0, { err: err, subject: subject }));\n        }\n    }\n    this.add(subject.subscribe(subscriber));\n}\nfunction dispatchNext(arg) {\n    var value = arg.value, subject = arg.subject;\n    subject.next(value);\n    subject.complete();\n}\nfunction dispatchError(arg) {\n    var err = arg.err, subject = arg.subject;\n    subject.error(err);\n}\n//# sourceMappingURL=bindNodeCallback.js.map\n","/** PURE_IMPORTS_START _Observable,_util_isArray,_operators_map,_util_isObject,_from PURE_IMPORTS_END */\nimport { Observable } from '../Observable';\nimport { isArray } from '../util/isArray';\nimport { map } from '../operators/map';\nimport { isObject } from '../util/isObject';\nimport { from } from './from';\nexport function forkJoin() {\n    var sources = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        sources[_i] = arguments[_i];\n    }\n    if (sources.length === 1) {\n        var first_1 = sources[0];\n        if (isArray(first_1)) {\n            return forkJoinInternal(first_1, null);\n        }\n        if (isObject(first_1) && Object.getPrototypeOf(first_1) === Object.prototype) {\n            var keys = Object.keys(first_1);\n            return forkJoinInternal(keys.map(function (key) { return first_1[key]; }), keys);\n        }\n    }\n    if (typeof sources[sources.length - 1] === 'function') {\n        var resultSelector_1 = sources.pop();\n        sources = (sources.length === 1 && isArray(sources[0])) ? sources[0] : sources;\n        return forkJoinInternal(sources, null).pipe(map(function (args) { return resultSelector_1.apply(void 0, args); }));\n    }\n    return forkJoinInternal(sources, null);\n}\nfunction forkJoinInternal(sources, keys) {\n    return new Observable(function (subscriber) {\n        var len = sources.length;\n        if (len === 0) {\n            subscriber.complete();\n            return;\n        }\n        var values = new Array(len);\n        var completed = 0;\n        var emitted = 0;\n        var _loop_1 = function (i) {\n            var source = from(sources[i]);\n            var hasValue = false;\n            subscriber.add(source.subscribe({\n                next: function (value) {\n                    if (!hasValue) {\n                        hasValue = true;\n                        emitted++;\n                    }\n                    values[i] = value;\n                },\n                error: function (err) { return subscriber.error(err); },\n                complete: function () {\n                    completed++;\n                    if (completed === len || !hasValue) {\n                        if (emitted === len) {\n                            subscriber.next(keys ?\n                                keys.reduce(function (result, key, i) { return (result[key] = values[i], result); }, {}) :\n                                values);\n                        }\n                        subscriber.complete();\n                    }\n                }\n            }));\n        };\n        for (var i = 0; i < len; i++) {\n            _loop_1(i);\n        }\n    });\n}\n//# sourceMappingURL=forkJoin.js.map\n","/** PURE_IMPORTS_START _Observable,_util_isArray,_util_isFunction,_operators_map PURE_IMPORTS_END */\nimport { Observable } from '../Observable';\nimport { isArray } from '../util/isArray';\nimport { isFunction } from '../util/isFunction';\nimport { map } from '../operators/map';\nexport function fromEventPattern(addHandler, removeHandler, resultSelector) {\n    if (resultSelector) {\n        return fromEventPattern(addHandler, removeHandler).pipe(map(function (args) { return isArray(args) ? resultSelector.apply(void 0, args) : resultSelector(args); }));\n    }\n    return new Observable(function (subscriber) {\n        var handler = function () {\n            var e = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                e[_i] = arguments[_i];\n            }\n            return subscriber.next(e.length === 1 ? e[0] : e);\n        };\n        var retValue;\n        try {\n            retValue = addHandler(handler);\n        }\n        catch (err) {\n            subscriber.error(err);\n            return undefined;\n        }\n        if (!isFunction(removeHandler)) {\n            return undefined;\n        }\n        return function () { return removeHandler(handler, retValue); };\n    });\n}\n//# sourceMappingURL=fromEventPattern.js.map\n","/** PURE_IMPORTS_START _Observable,_util_identity,_util_isScheduler PURE_IMPORTS_END */\nimport { Observable } from '../Observable';\nimport { identity } from '../util/identity';\nimport { isScheduler } from '../util/isScheduler';\nexport function generate(initialStateOrOptions, condition, iterate, resultSelectorOrObservable, scheduler) {\n    var resultSelector;\n    var initialState;\n    if (arguments.length == 1) {\n        var options = initialStateOrOptions;\n        initialState = options.initialState;\n        condition = options.condition;\n        iterate = options.iterate;\n        resultSelector = options.resultSelector || identity;\n        scheduler = options.scheduler;\n    }\n    else if (resultSelectorOrObservable === undefined || isScheduler(resultSelectorOrObservable)) {\n        initialState = initialStateOrOptions;\n        resultSelector = identity;\n        scheduler = resultSelectorOrObservable;\n    }\n    else {\n        initialState = initialStateOrOptions;\n        resultSelector = resultSelectorOrObservable;\n    }\n    return new Observable(function (subscriber) {\n        var state = initialState;\n        if (scheduler) {\n            return scheduler.schedule(dispatch, 0, {\n                subscriber: subscriber,\n                iterate: iterate,\n                condition: condition,\n                resultSelector: resultSelector,\n                state: state\n            });\n        }\n        do {\n            if (condition) {\n                var conditionResult = void 0;\n                try {\n                    conditionResult = condition(state);\n                }\n                catch (err) {\n                    subscriber.error(err);\n                    return undefined;\n                }\n                if (!conditionResult) {\n                    subscriber.complete();\n                    break;\n                }\n            }\n            var value = void 0;\n            try {\n                value = resultSelector(state);\n            }\n            catch (err) {\n                subscriber.error(err);\n                return undefined;\n            }\n            subscriber.next(value);\n            if (subscriber.closed) {\n                break;\n            }\n            try {\n                state = iterate(state);\n            }\n            catch (err) {\n                subscriber.error(err);\n                return undefined;\n            }\n        } while (true);\n        return undefined;\n    });\n}\nfunction dispatch(state) {\n    var subscriber = state.subscriber, condition = state.condition;\n    if (subscriber.closed) {\n        return undefined;\n    }\n    if (state.needIterate) {\n        try {\n            state.state = state.iterate(state.state);\n        }\n        catch (err) {\n            subscriber.error(err);\n            return undefined;\n        }\n    }\n    else {\n        state.needIterate = true;\n    }\n    if (condition) {\n        var conditionResult = void 0;\n        try {\n            conditionResult = condition(state.state);\n        }\n        catch (err) {\n            subscriber.error(err);\n            return undefined;\n        }\n        if (!conditionResult) {\n            subscriber.complete();\n            return undefined;\n        }\n        if (subscriber.closed) {\n            return undefined;\n        }\n    }\n    var value;\n    try {\n        value = state.resultSelector(state.state);\n    }\n    catch (err) {\n        subscriber.error(err);\n        return undefined;\n    }\n    if (subscriber.closed) {\n        return undefined;\n    }\n    subscriber.next(value);\n    if (subscriber.closed) {\n        return undefined;\n    }\n    return this.schedule(state);\n}\n//# sourceMappingURL=generate.js.map\n","/** PURE_IMPORTS_START _defer,_empty PURE_IMPORTS_END */\nimport { defer } from './defer';\nimport { EMPTY } from './empty';\nexport function iif(condition, trueResult, falseResult) {\n    if (trueResult === void 0) {\n        trueResult = EMPTY;\n    }\n    if (falseResult === void 0) {\n        falseResult = EMPTY;\n    }\n    return defer(function () { return condition() ? trueResult : falseResult; });\n}\n//# sourceMappingURL=iif.js.map\n","/** PURE_IMPORTS_START _Observable,_scheduler_async,_util_isNumeric PURE_IMPORTS_END */\nimport { Observable } from '../Observable';\nimport { async } from '../scheduler/async';\nimport { isNumeric } from '../util/isNumeric';\nexport function interval(period, scheduler) {\n    if (period === void 0) {\n        period = 0;\n    }\n    if (scheduler === void 0) {\n        scheduler = async;\n    }\n    if (!isNumeric(period) || period < 0) {\n        period = 0;\n    }\n    if (!scheduler || typeof scheduler.schedule !== 'function') {\n        scheduler = async;\n    }\n    return new Observable(function (subscriber) {\n        subscriber.add(scheduler.schedule(dispatch, period, { subscriber: subscriber, counter: 0, period: period }));\n        return subscriber;\n    });\n}\nfunction dispatch(state) {\n    var subscriber = state.subscriber, counter = state.counter, period = state.period;\n    subscriber.next(counter);\n    this.schedule({ subscriber: subscriber, counter: counter + 1, period: period }, period);\n}\n//# sourceMappingURL=interval.js.map\n","/** PURE_IMPORTS_START _Observable,_util_noop PURE_IMPORTS_END */\nimport { Observable } from '../Observable';\nimport { noop } from '../util/noop';\nexport var NEVER = /*@__PURE__*/ new Observable(noop);\nexport function never() {\n    return NEVER;\n}\n//# sourceMappingURL=never.js.map\n","/** PURE_IMPORTS_START _Observable,_from,_util_isArray,_empty PURE_IMPORTS_END */\nimport { Observable } from '../Observable';\nimport { from } from './from';\nimport { isArray } from '../util/isArray';\nimport { EMPTY } from './empty';\nexport function onErrorResumeNext() {\n    var sources = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        sources[_i] = arguments[_i];\n    }\n    if (sources.length === 0) {\n        return EMPTY;\n    }\n    var first = sources[0], remainder = sources.slice(1);\n    if (sources.length === 1 && isArray(first)) {\n        return onErrorResumeNext.apply(void 0, first);\n    }\n    return new Observable(function (subscriber) {\n        var subNext = function () { return subscriber.add(onErrorResumeNext.apply(void 0, remainder).subscribe(subscriber)); };\n        return from(first).subscribe({\n            next: function (value) { subscriber.next(value); },\n            error: subNext,\n            complete: subNext,\n        });\n    });\n}\n//# sourceMappingURL=onErrorResumeNext.js.map\n","/** PURE_IMPORTS_START _Observable,_Subscription PURE_IMPORTS_END */\nimport { Observable } from '../Observable';\nimport { Subscription } from '../Subscription';\nexport function pairs(obj, scheduler) {\n    if (!scheduler) {\n        return new Observable(function (subscriber) {\n            var keys = Object.keys(obj);\n            for (var i = 0; i < keys.length && !subscriber.closed; i++) {\n                var key = keys[i];\n                if (obj.hasOwnProperty(key)) {\n                    subscriber.next([key, obj[key]]);\n                }\n            }\n            subscriber.complete();\n        });\n    }\n    else {\n        return new Observable(function (subscriber) {\n            var keys = Object.keys(obj);\n            var subscription = new Subscription();\n            subscription.add(scheduler.schedule(dispatch, 0, { keys: keys, index: 0, subscriber: subscriber, subscription: subscription, obj: obj }));\n            return subscription;\n        });\n    }\n}\nexport function dispatch(state) {\n    var keys = state.keys, index = state.index, subscriber = state.subscriber, subscription = state.subscription, obj = state.obj;\n    if (!subscriber.closed) {\n        if (index < keys.length) {\n            var key = keys[index];\n            subscriber.next([key, obj[key]]);\n            subscription.add(this.schedule({ keys: keys, index: index + 1, subscriber: subscriber, subscription: subscription, obj: obj }));\n        }\n        else {\n            subscriber.complete();\n        }\n    }\n}\n//# sourceMappingURL=pairs.js.map\n","/** PURE_IMPORTS_START _util_not,_util_subscribeTo,_operators_filter,_Observable PURE_IMPORTS_END */\nimport { not } from '../util/not';\nimport { subscribeTo } from '../util/subscribeTo';\nimport { filter } from '../operators/filter';\nimport { Observable } from '../Observable';\nexport function partition(source, predicate, thisArg) {\n    return [\n        filter(predicate, thisArg)(new Observable(subscribeTo(source))),\n        filter(not(predicate, thisArg))(new Observable(subscribeTo(source)))\n    ];\n}\n//# sourceMappingURL=partition.js.map\n","/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */\nimport { Observable } from '../Observable';\nexport function range(start, count, scheduler) {\n    if (start === void 0) {\n        start = 0;\n    }\n    return new Observable(function (subscriber) {\n        if (count === undefined) {\n            count = start;\n            start = 0;\n        }\n        var index = 0;\n        var current = start;\n        if (scheduler) {\n            return scheduler.schedule(dispatch, 0, {\n                index: index, count: count, start: start, subscriber: subscriber\n            });\n        }\n        else {\n            do {\n                if (index++ >= count) {\n                    subscriber.complete();\n                    break;\n                }\n                subscriber.next(current++);\n                if (subscriber.closed) {\n                    break;\n                }\n            } while (true);\n        }\n        return undefined;\n    });\n}\nexport function dispatch(state) {\n    var start = state.start, index = state.index, count = state.count, subscriber = state.subscriber;\n    if (index >= count) {\n        subscriber.complete();\n        return;\n    }\n    subscriber.next(start);\n    if (subscriber.closed) {\n        return;\n    }\n    state.index = index + 1;\n    state.start = start + 1;\n    this.schedule(state);\n}\n//# sourceMappingURL=range.js.map\n","/** PURE_IMPORTS_START _Observable,_from,_empty PURE_IMPORTS_END */\nimport { Observable } from '../Observable';\nimport { from } from './from';\nimport { EMPTY } from './empty';\nexport function using(resourceFactory, observableFactory) {\n    return new Observable(function (subscriber) {\n        var resource;\n        try {\n            resource = resourceFactory();\n        }\n        catch (err) {\n            subscriber.error(err);\n            return undefined;\n        }\n        var result;\n        try {\n            result = observableFactory(resource);\n        }\n        catch (err) {\n            subscriber.error(err);\n            return undefined;\n        }\n        var source = result ? from(result) : EMPTY;\n        var subscription = source.subscribe(subscriber);\n        return function () {\n            subscription.unsubscribe();\n            if (resource) {\n                resource.unsubscribe();\n            }\n        };\n    });\n}\n//# sourceMappingURL=using.js.map\n","/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */\nimport { Observable } from '../Observable';\nexport var EMPTY = /*@__PURE__*/ new Observable(function (subscriber) { return subscriber.complete(); });\nexport function empty(scheduler) {\n    return scheduler ? emptyScheduled(scheduler) : EMPTY;\n}\nfunction emptyScheduled(scheduler) {\n    return new Observable(function (subscriber) { return scheduler.schedule(function () { return subscriber.complete(); }); });\n}\n//# sourceMappingURL=empty.js.map\n","/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subscriber } from './Subscriber';\nvar OuterSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(OuterSubscriber, _super);\n    function OuterSubscriber() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.destination.next(innerValue);\n    };\n    OuterSubscriber.prototype.notifyError = function (error, innerSub) {\n        this.destination.error(error);\n    };\n    OuterSubscriber.prototype.notifyComplete = function (innerSub) {\n        this.destination.complete();\n    };\n    return OuterSubscriber;\n}(Subscriber));\nexport { OuterSubscriber };\n//# sourceMappingURL=OuterSubscriber.js.map\n","/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subscriber } from '../Subscriber';\nexport function filter(predicate, thisArg) {\n    return function filterOperatorFunction(source) {\n        return source.lift(new FilterOperator(predicate, thisArg));\n    };\n}\nvar FilterOperator = /*@__PURE__*/ (function () {\n    function FilterOperator(predicate, thisArg) {\n        this.predicate = predicate;\n        this.thisArg = thisArg;\n    }\n    FilterOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));\n    };\n    return FilterOperator;\n}());\nvar FilterSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(FilterSubscriber, _super);\n    function FilterSubscriber(destination, predicate, thisArg) {\n        var _this = _super.call(this, destination) || this;\n        _this.predicate = predicate;\n        _this.thisArg = thisArg;\n        _this.count = 0;\n        return _this;\n    }\n    FilterSubscriber.prototype._next = function (value) {\n        var result;\n        try {\n            result = this.predicate.call(this.thisArg, value, this.count++);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        if (result) {\n            this.destination.next(value);\n        }\n    };\n    return FilterSubscriber;\n}(Subscriber));\n//# sourceMappingURL=filter.js.map\n","/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subscriber } from './Subscriber';\nvar InnerSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(InnerSubscriber, _super);\n    function InnerSubscriber(parent, outerValue, outerIndex) {\n        var _this = _super.call(this) || this;\n        _this.parent = parent;\n        _this.outerValue = outerValue;\n        _this.outerIndex = outerIndex;\n        _this.index = 0;\n        return _this;\n    }\n    InnerSubscriber.prototype._next = function (value) {\n        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);\n    };\n    InnerSubscriber.prototype._error = function (error) {\n        this.parent.notifyError(error, this);\n        this.unsubscribe();\n    };\n    InnerSubscriber.prototype._complete = function () {\n        this.parent.notifyComplete(this);\n        this.unsubscribe();\n    };\n    return InnerSubscriber;\n}(Subscriber));\nexport { InnerSubscriber };\n//# sourceMappingURL=InnerSubscriber.js.map\n","/** PURE_IMPORTS_START _InnerSubscriber,_subscribeTo,_Observable PURE_IMPORTS_END */\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeTo } from './subscribeTo';\nimport { Observable } from '../Observable';\nexport function subscribeToResult(outerSubscriber, result, outerValue, outerIndex, innerSubscriber) {\n    if (innerSubscriber === void 0) {\n        innerSubscriber = new InnerSubscriber(outerSubscriber, outerValue, outerIndex);\n    }\n    if (innerSubscriber.closed) {\n        return undefined;\n    }\n    if (result instanceof Observable) {\n        return result.subscribe(innerSubscriber);\n    }\n    return subscribeTo(result)(innerSubscriber);\n}\n//# sourceMappingURL=subscribeToResult.js.map\n","/** PURE_IMPORTS_START _observable_empty,_observable_of,_observable_throwError PURE_IMPORTS_END */\nimport { empty } from './observable/empty';\nimport { of } from './observable/of';\nimport { throwError } from './observable/throwError';\nexport var NotificationKind;\n/*@__PURE__*/ (function (NotificationKind) {\n    NotificationKind[\"NEXT\"] = \"N\";\n    NotificationKind[\"ERROR\"] = \"E\";\n    NotificationKind[\"COMPLETE\"] = \"C\";\n})(NotificationKind || (NotificationKind = {}));\nvar Notification = /*@__PURE__*/ (function () {\n    function Notification(kind, value, error) {\n        this.kind = kind;\n        this.value = value;\n        this.error = error;\n        this.hasValue = kind === 'N';\n    }\n    Notification.prototype.observe = function (observer) {\n        switch (this.kind) {\n            case 'N':\n                return observer.next && observer.next(this.value);\n            case 'E':\n                return observer.error && observer.error(this.error);\n            case 'C':\n                return observer.complete && observer.complete();\n        }\n    };\n    Notification.prototype.do = function (next, error, complete) {\n        var kind = this.kind;\n        switch (kind) {\n            case 'N':\n                return next && next(this.value);\n            case 'E':\n                return error && error(this.error);\n            case 'C':\n                return complete && complete();\n        }\n    };\n    Notification.prototype.accept = function (nextOrObserver, error, complete) {\n        if (nextOrObserver && typeof nextOrObserver.next === 'function') {\n            return this.observe(nextOrObserver);\n        }\n        else {\n            return this.do(nextOrObserver, error, complete);\n        }\n    };\n    Notification.prototype.toObservable = function () {\n        var kind = this.kind;\n        switch (kind) {\n            case 'N':\n                return of(this.value);\n            case 'E':\n                return throwError(this.error);\n            case 'C':\n                return empty();\n        }\n        throw new Error('unexpected notification kind value');\n    };\n    Notification.createNext = function (value) {\n        if (typeof value !== 'undefined') {\n            return new Notification('N', value);\n        }\n        return Notification.undefinedValueNotification;\n    };\n    Notification.createError = function (err) {\n        return new Notification('E', undefined, err);\n    };\n    Notification.createComplete = function () {\n        return Notification.completeNotification;\n    };\n    Notification.completeNotification = new Notification('C');\n    Notification.undefinedValueNotification = new Notification('N', undefined);\n    return Notification;\n}());\nexport { Notification };\n//# sourceMappingURL=Notification.js.map\n","/** PURE_IMPORTS_START  PURE_IMPORTS_END */\nvar ArgumentOutOfRangeErrorImpl = /*@__PURE__*/ (function () {\n    function ArgumentOutOfRangeErrorImpl() {\n        Error.call(this);\n        this.message = 'argument out of range';\n        this.name = 'ArgumentOutOfRangeError';\n        return this;\n    }\n    ArgumentOutOfRangeErrorImpl.prototype = /*@__PURE__*/ Object.create(Error.prototype);\n    return ArgumentOutOfRangeErrorImpl;\n})();\nexport var ArgumentOutOfRangeError = ArgumentOutOfRangeErrorImpl;\n//# sourceMappingURL=ArgumentOutOfRangeError.js.map\n","/** PURE_IMPORTS_START  PURE_IMPORTS_END */\nvar EmptyErrorImpl = /*@__PURE__*/ (function () {\n    function EmptyErrorImpl() {\n        Error.call(this);\n        this.message = 'no elements in sequence';\n        this.name = 'EmptyError';\n        return this;\n    }\n    EmptyErrorImpl.prototype = /*@__PURE__*/ Object.create(Error.prototype);\n    return EmptyErrorImpl;\n})();\nexport var EmptyError = EmptyErrorImpl;\n//# sourceMappingURL=EmptyError.js.map\n","/** PURE_IMPORTS_START _util_isScheduler,_fromArray,_scheduled_scheduleArray PURE_IMPORTS_END */\nimport { isScheduler } from '../util/isScheduler';\nimport { fromArray } from './fromArray';\nimport { scheduleArray } from '../scheduled/scheduleArray';\nexport function of() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    var scheduler = args[args.length - 1];\n    if (isScheduler(scheduler)) {\n        args.pop();\n        return scheduleArray(args, scheduler);\n    }\n    else {\n        return fromArray(args);\n    }\n}\n//# sourceMappingURL=of.js.map\n","/** PURE_IMPORTS_START tslib,_Subject,_Subscription PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subject } from './Subject';\nimport { Subscription } from './Subscription';\nvar AsyncSubject = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(AsyncSubject, _super);\n    function AsyncSubject() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.value = null;\n        _this.hasNext = false;\n        _this.hasCompleted = false;\n        return _this;\n    }\n    AsyncSubject.prototype._subscribe = function (subscriber) {\n        if (this.hasError) {\n            subscriber.error(this.thrownError);\n            return Subscription.EMPTY;\n        }\n        else if (this.hasCompleted && this.hasNext) {\n            subscriber.next(this.value);\n            subscriber.complete();\n            return Subscription.EMPTY;\n        }\n        return _super.prototype._subscribe.call(this, subscriber);\n    };\n    AsyncSubject.prototype.next = function (value) {\n        if (!this.hasCompleted) {\n            this.value = value;\n            this.hasNext = true;\n        }\n    };\n    AsyncSubject.prototype.error = function (error) {\n        if (!this.hasCompleted) {\n            _super.prototype.error.call(this, error);\n        }\n    };\n    AsyncSubject.prototype.complete = function () {\n        this.hasCompleted = true;\n        if (this.hasNext) {\n            _super.prototype.next.call(this, this.value);\n        }\n        _super.prototype.complete.call(this);\n    };\n    return AsyncSubject;\n}(Subject));\nexport { AsyncSubject };\n//# sourceMappingURL=AsyncSubject.js.map\n","/** PURE_IMPORTS_START _of,_operators_concatAll PURE_IMPORTS_END */\nimport { of } from './of';\nimport { concatAll } from '../operators/concatAll';\nexport function concat() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i] = arguments[_i];\n    }\n    return concatAll()(of.apply(void 0, observables));\n}\n//# sourceMappingURL=concat.js.map\n"],"sourceRoot":""}